---
layout:             post
title:              "ARM32 Boot Stage 1 源码分析"
date:               2019-03-27 07:36:30 +0800
categories:         [MMU]
excerpt:            ARM32 Boot Stage 1 源码分析.
tags:
  - MMU
---

> [GitHub ASM code: .macro](https://github.com/BiscuitOS/HardStack/tree/master/Language/Assembly/ARM-GNU-Assembly/Instruction/%5B.macro%5D)
>
> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

# 目录

> - [原理](#原理)
>
> - [实践](#实践)
>
> - [附录](#附录)

--------------------------------------------------------------
<span id="原理"></span>

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/IND00000A.jpg)

# 原理

##### Boot Stage 1 起始地址定位

Boot Stage 1 是 uboot 将压缩好的内核加载到内核之后开始，到内核被解压出来结束。
这个阶段主要的作用就是解压内核镜像，并构建内核的各个 section。其源码位于
arch/arm/boot/compressed/ 目录下。其基本原理就是将这个目录下的源码编译链接成
一个独立的 ELF 文件，名为 vmlinux，这个 vmlinux 与内核的 vmlinux 名字相似，但
要注意区分，这个 vmlinux 是一个独立的 ELF 文件，位于 arch/arm/boot/compressed/
目录下，所以需要调试这部分代码的开发者，调试的对象是该目录下的 vmlinux，而不是内核
的 vmlinux。开发者可以参考下文进行这部分代码的 GDB 在线调试：

> [Arm32 Boot Stage 1 阶段 GDB 调试方法](https://biscuitos.github.io/blog/BOOTASM-debuggingTools/#ARM%20Boot-Stage1)

对于 Boot Stage 1 的入口函数，可以通过该目录下的 vmlinux.lds.S 文件进行确认，
具体内容如下：

{% highlight base %}
ENTRY(_start)
SECTIONS
{
  . = TEXT_START;
  _text = .;

  .text : {
    _start = .;
    *(.start)
    *(.text)
    *(.text.*)
    *(.fixup)
    *(.gnu.warning)
    *(.glue_7t)
    *(.glue_7)
  }
{% endhighlight %}

从链接脚本可以知道 vmlinux 链接过程，使用 ENTRY 关键字指定了 vmlinux 的入口地址，
也就是第一行运行的代码，这里设置为 _start, 从上面可以看出 _start 位于 .text section
的首地址，所以这里链接脚本告诉开发者，vmlinux 运行的第一行代码就是 vmlinux .text
section 的第一行代码。继续查看链接脚本， .text section 的布局是所有目标文件的
.start section 位于 vmlinux .text section 的最前部，所以开发者只需找到目标文件
中函数 .start section 的文件即可。更多链接脚本的学习可以查看下列文档：

> [GNU LD scripts 详细教程](https://biscuitos.github.io/blog/LD/)

查找 arch/arm/boot/compressed/ 目录下，含有 .start section 的源码位于

{% highlight base %}
arch/arm/boot/compressed$ grep "\.start" * -nR
big-endian.S:9:	.section ".start", #alloc, #execinstr
Binary file head.o matches
head.S:146:		.section ".start", #alloc, #execinstr
head-sa1100.S:14:		.section        ".start", "ax"
head-sharpsl.S:23:		.section        ".start", "ax"
head-xscale.S:11:		.section        ".start", "ax"
{% endhighlight %}

所以该目录下一共有 4 个文件含有 .start section. 接下来就要根据 Makefile 来确定
 .start section 链接先后顺序了。

{% highlight base %}
HEAD    = head.o

ifeq ($(CONFIG_ARCH_SA1100),y)
OBJS            += head-sa1100.o
endif

ifeq ($(CONFIG_CPU_XSCALE),y)
OBJS            += head-xscale.o
endif

ifeq ($(CONFIG_PXA_SHARPSL_DETECT_MACH_ID),y)
OBJS            += head-sharpsl.o
endif

ifeq ($(CONFIG_CPU_ENDIAN_BE32),y)
ifeq ($(CONFIG_CPU_CP15),y)
OBJS            += big-endian.o
else

$(obj)/vmlinux: $(obj)/vmlinux.lds $(obj)/$(HEAD) $(obj)/piggy.o \
                $(addprefix $(obj)/, $(OBJS)) $(lib1funcs) $(ashldi3) \
                $(bswapsdi2) $(efi-obj-y) FORCE
        @$(check_for_multiple_zreladdr)
        $(call if_changed,ld)
        @$(check_for_bad_syms)
{% endhighlight %}

从 Makefile 编译位置上可以知道，生成 vmlinux 的时候，head.S 最先被链接到 vmlinux
里面，接着是 head-sa1100.o，head-xscale.o， head-sharpsl.o， big-endian.o。
所以 vmlinux .text section 第一个 section 从 head.S 的 .start section 开始。
接下来就开始从 head.S 开始分析。

##### head.S

在 head.S 文件中，可以找到 .start section, 源码如下（代码较长，分段解析）：

{% highlight base %}
                .section ".start", #alloc, #execinstr
/*
 * sort out different calling conventions
 */
                .align
                /*
                 * Always enter in ARM state for CPUs that support the ARM ISA.
                 * As of today (2014) that's exactly the members of the A and R
                 * classes.
                 */
 AR_CLASS(      .arm    )
start:
                .type   start,#function
                .rept   7
                __nop
                .endr
{% endhighlight %}

首先使用 .section 伪指令定义了一个名为 .start 的 section，并定义了 section
的属性是可分配和可执行的，使用 objdump 工具查看其 ELF 信息：

{% highlight base %}
$objdump -sShxd head.o

head.o:     file format elf32-little
head.o
architecture: UNKNOWN!, flags 0x00000011:
HAS_RELOC, HAS_SYMS
start address 0x00000000

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000890  00000000  00000000  00000040  2**5
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  1 .data         00000000  00000000  00000000  000008d0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000000  00000000  00000000  000008d0  2**0
                  ALLOC
  3 .start        00000098  00000000  00000000  000008d0  2**2
                  CONTENTS, ALLOC, LOAD, RELOC, READONLY, CODE
  4 .stack        00001000  00000000  00000000  00000968  2**0
                  ALLOC
  5 .debug_line   00000277  00000000  00000000  00000968  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  6 .debug_info   00000092  00000000  00000000  00000bdf  2**0
                  CONTENTS, RELOC, READONLY, DEBUGGING
  7 .debug_abbrev 00000012  00000000  00000000  00000c71  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_aranges 00000028  00000000  00000000  00000c88  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING
  9 .debug_ranges 00000020  00000000  00000000  00000cb0  2**3
                  CONTENTS, RELOC, READONLY, DEBUGGING
 10 .ARM.attributes 0000001f  00000000  00000000  00000cd0  2**0
                  CONTENTS, READONLY
{% endhighlight %}

从上面的运行结果可以看出，.start section 的属性为 CONTENTS, ALLOC, LOAD, RELOC,
READONLY, CODE，这些属性正好符合定义时的属性，这正好是一个代码段该有的属性。

接着使用了 .align 伪指令和 .arm 伪指令告诉汇编器，这是一个使用 arm32 指令集并
要求对齐的 section。创建第一个标号 start，开发者可以使用 GDB 工具在 start 处
打断点进行调试。紧接着调用 .type 伪指令告诉汇编器，start 这个标号的类型是一个
#function，也就是 start 标号是一个函数类型。.rept 伪指令和 .endr 伪指令配合
使用，告诉汇编器，这里需要循环 7 次，每次都执行 .rept 伪指令和 .endr 伪指令
之间的代码，这里对应的代码就是 __nop 宏，实现了 7 次等待动作。__nop 宏定义如下：

{% highlight base %}
                .macro  __nop
#ifdef CONFIG_EFI_STUB
                @ This is almost but not quite a NOP, since it does clobber the
                @ condition flags. But it is the best we can do for EFI, since
                @ PE/COFF expects the magic string "MZ" at offset 0, while the
                @ ARM/Linux boot protocol expects an executable instruction
                @ there.
                .inst   MZ_MAGIC | (0x1310 << 16)       @ tstne r0, #0x4d000
#else
 AR_CLASS(      mov     r0, r0          )
  M_CLASS(      nop.w                   )
#endif
                .endm
{% endhighlight %}

由于本实践过程没有考虑 CONFIG_ELF_STUB 对应的内容，所以调用 .marco 伪指令和
.endm 伪指令定义了 __nop 宏的过程是 “mov r0, r0”， 也就是无意义的操作，起到延时
的作用。接着继续分析 head.S 里面的代码，内容如下：

{% highlight base %}
#ifndef CONFIG_THUMB2_KERNEL
                mov     r0, r0
#else
 AR_CLASS(      sub     pc, pc, #3      )       @ A/R: switch to Thumb2 mode
  M_CLASS(      nop.w                   )       @ M: already in Thumb2 mode
                .thumb
#endif
                W(b)    1f

                .word   _magic_sig      @ Magic numbers to help the loader
                .word   _magic_start    @ absolute load/run zImage address
                .word   _magic_end      @ zImage end address
                .word   0x04030201      @ endianness flag
                .word   0x45454545      @ another magic number to indicate
                .word   _magic_table    @ additional data table

                __EFI_HEADER
1:
{% endhighlight %}

这段代码首先判断有没有定义 CONFIG_THUMB2_KERNEL 宏，以此确定内核此时是否支持
Thumb 指令集，由于本实践未打开这个宏，所以不执行对应的功能。代码中，没有打开
CONFIG_THUBM2_KERNEL 宏之后，只调用 "mov r0, r0"，一个空操作，等效于 nop，
接着代码条用 b 指令直接跳转到 1f 标签处继续执行。在 1 标签之前，代码为数据分配
了一些存储空间，这些数据也位于 .start section 内部，由于这个段的属性可知，
这些数据是只读而不可写的。下面来分析这些数据的含义:

> _magic_sig 用于存储 Magic 号，加载时候有用
>
> _magic_start 用于指定 zImage 的加载和运行的绝对地址
>
> _magic_end 用于指定 zImage 的结束地址
>
> 0x04030201 表示字节序标志
>
> 0x45454545 表示另一个 Magic 号
>
> _magic_table 指向附加的数据表
>
> __EFI_HEADER 指向 EFI 头

以上的数据用于 zImage 加载和运行时候使用，其具体的数字是 vmlinux 加载的时候
就决定了，可以通过查看 vmlinux.lds.S 链接脚本查看，部分内容如下：

{% highlight base %}
  .table : ALIGN(4) {
    _table_start = .;
    LONG(ZIMAGE_MAGIC(2))
    LONG(ZIMAGE_MAGIC(0x5a534c4b))
    LONG(ZIMAGE_MAGIC(__piggy_size_addr - _start))
    LONG(ZIMAGE_MAGIC(_kernel_bss_size))
    LONG(0)
    _table_end = .;
  }

  _magic_sig = ZIMAGE_MAGIC(0x016f2818);
  _magic_start = ZIMAGE_MAGIC(_start);
  _magic_end = ZIMAGE_MAGIC(_edata);
  _magic_table = ZIMAGE_MAGIC(_table_start - _start);
{% endhighlight %}

链接过程中，创建了一个名为 .table section，这个 section 按四个字节对齐，
首先定义了 _table_start 指向 section 的起始地址，然后定义了一个 LONG 变量
存储 ZIMAGE_MAGIC(2) 的值，接着定义了一个 LONG 变量存储 ZIMAGE_MAGIC(0x5a534c4b)
的值；定义一个 LONG 变量用于存储 ZIMAGE_MAGIC(__piggy_size_addr - _start)
的值，也就是 __piggy_size_addr 到 _start 之间的长度；第一个 LONG 变量存储
ZIMAGE_MAGIC(_kernel_bss_size) 的值，也就是内核 .bss section 的值；最后定义了
一个为 0 的 LONG 值，以及定义 _table_end 指向 .table section 的结束地址。
接着在 vmlinux.lds.S 链接脚本中，给 _magic_sig 赋值为 ZIMAGE_MAGIC(0x016f2818);
给 _magic_start 赋值为 ZIMAGE_MAGIC(_start)；给 _magic_end 赋值为
ZIMAGE_MAGIC(_edata)；_magic_table 赋值给了 ZIMAGE_MAGIC(_table_start - _start)，
接着开发者可以使用 GDB 工具实践看看运行时布局,如下：

{% highlight bash %}
(gdb) target remote :1234
Remote debugging using :1234
_text () at arch/arm/boot/compressed/head.S:161
warning: Source file is more recent than executable.
161			.endr
(gdb) b BS_debug
Breakpoint 1 at 0x3c: file arch/arm/boot/compressed/head.S, line 181.
(gdb) c
Continuing.

Breakpoint 1, BS_debug () at arch/arm/boot/compressed/head.S:181
181			bl BS_func
(gdb) list
176			.word	_magic_table	@ additional data table
177
178			__EFI_HEADER
179	1:
180	ENTRY(BS_debug)
181			bl BS_func
182	 ARM_BE8(	setend	be		)	@ go BE8 if compiled for BE8
183	 AR_CLASS(	mrs	r9, cpsr	)
184	#ifdef CONFIG_ARM_VIRT_EXT
185			bl	__hyp_stub_install	@ get into SVC mode, reversibly
(gdb) print &_magic_sig
$1 = (<variable (not text or data), no debug info> *) 0x16f2818
(gdb) print &_magic_start
$2 = (<text variable, no debug info> *) 0x0 <_text>
(gdb) print &_magic_end
$3 = (<variable (not text or data), no debug info> *) 0x42ba08 <free_mem_end_ptr>
(gdb) print &_magic_table
$4 = (<variable (not text or data), no debug info> *) 0x3af8
(gdb)
{% endhighlight %}

在使用 objdump 工具查看 vmlinux 的 .text section, 内容如下：

{% highlight bash %}
$ objdump -sShdx vmlinux

Contents of section .text:
 0000 0000a0e1 0000a0e1 0000a0e1 0000a0e1  ................
 0010 0000a0e1 0000a0e1 0000a0e1 0000a0e1  ................
 0020 050000ea 18286f01 00000000 08ba4200  .....(o.......B.
 0030 01020304 45454545 f83a0000 d00d00eb  ....EEEE.:......
 0040 00900fe1 8d0d00eb 0170a0e1 0280a0e1  .........p......
 0050 00200fe1 030012e3 0100001a 1700a0e3  . ..............
 0060 563412ef 00000fe1 1a0020e2 1f0010e3  V4........ .....
 0070 1f00c0e3 d30080e3 0400001a 010c80e3  ................
{% endhighlight %}

从上面的运行分析之后，可以知道，在 .text section 的头部定义了一个 zImage 的
 Magic 头，这个 zImage Magic 头的布局如下：

{% highlight bash %}

+-------------------------------------+ low_addr
|            Magic Number             |
+-------------------------------------+
|         Magic Start Address         |
+-------------------------------------+
|          Magic End Address          |
+-------------------------------------+
|             0x01020304              |
+-------------------------------------+
|             0x45454545              |
+-------------------------------------+
|      Magic Table Base Address       |
+-------------------------------------+
|            __EFI_HEADER             |
+-------------------------------------+ high_addr
{% endhighlight %}

__EFI_HEADER 定义在 elf-header.S 文件中，由于本实践不支持 CONFIG_EFI_STUB 功能，
所以这里不讨论这个部分。接着继续讨论 head.S 文件中内容。

{% highlight bash %}
 ARM_BE8(       setend  be              )       @ go BE8 if compiled for BE8
 AR_CLASS(      mrs     r9, cpsr        )
#ifdef CONFIG_ARM_VIRT_EXT
                bl      __hyp_stub_install      @ get into SVC mode, reversibly
#endif
{% endhighlight %}

由于不支持 ARM_BE8, 所以 "setend be" 指令不被执行，继续执行 "mrs r9, cpsr"
指令，这个指令的作用就是将 CPSR 寄存器的值存储到 R9 寄存器中。接下来检查是否支持
CONFIG_ARM_VIRT_EXT 拓展，本实践平台上支持这个功能，所以接上来调用 "bl __hyp_stub_install"
指令。__hyp_stub_install 函数定义在 hyp-stub.S 文件中，如下：

{% highlight bash %}
/*
 * Hypervisor stub installation functions.
 *
 * These must be called with the MMU and D-cache off.
 * They are not ABI compliant and are only intended to be called from the kernel
 * entry points in head.S.
 */
@ Call this from the primary CPU
ENTRY(__hyp_stub_install)
        store_primary_cpu_mode  r4, r5, r6
ENDPROC(__hyp_stub_install)

        @ fall through...

@ Secondary CPUs should call here
ENTRY(__hyp_stub_install_secondary)



        .macro  store_primary_cpu_mode  reg1:req, reg2:req, reg3:req
        .endm
{% endhighlight %}


从函数的注释可以看出，函数的作用是安装管理程序， __hyp_stub_install 函数内部调用
了 store_primary_cpu_mode 宏，并传入 r4, r5, 和 r6 三个参数，由于
store_primary_cpu_mode 宏的定义里不做任何实际操作，那么 __hyp_stub_install
函数就继续执行 __hyp_stub_install_secondary 函数，函数的源码如下：

{% highlight bash %}
/*
 * The zImage loader only runs on one CPU, so we don't bother with mult-CPU
 * consistency checking:
 */
        .macro  compare_cpu_mode_with_primary mode, reg1, reg2, reg3
        cmp     \mode, \mode
        .endm

@ Secondary CPUs should call here
ENTRY(__hyp_stub_install_secondary)
        mrs     r4, cpsr
        and     r4, r4, #MODE_MASK

        /*
         * If the secondary has booted with a different mode, give up
         * immediately.
         */
        compare_cpu_mode_with_primary   r4, r5, r6, r7
        retne   lr

        /*
         * Once we have given up on one CPU, we do not try to install the
         * stub hypervisor on the remaining ones: because the saved boot mode
         * is modified, it can't compare equal to the CPSR mode field any
         * more.
         *
         * Otherwise...
         */

        cmp     r4, #HYP_MODE
        retne   lr                      @ give up if the CPU is not in HYP mode
{% endhighlight %}

函数首先调用 mrs 指令将 CPSR 寄存器的值存储到 R4 寄存器里，然后调用 and 指令
将 r4 中的值与 MODE_MASK 相与，结果存放在 r4 中，总所周知，CPSR 的第 5 位描述当前
CPU 的模式，如下图：

{% highlight bash %}
CPSR：

  32        27         25     20        16        10        5        0
  +-+-+-+-+-+----------+-+----+---------+---------+-+-+-+-+-+--------+
  | | | | | |          | |    |         |         | | | | | |        |
  |N|Z|C|V|Q| IT[1:0]  |J|    | GE[3:0] | IT[7:2] |E|A|I|F|T| M[4:0] |
  | | | | | |          | |    |         |         | | | | | |        |
  +-+-+-+-+-+----------+-+----+---------+---------+-+-+-+-+-+--------+
  | <-----> |                                       | <-> |
   Condition                                       Mask bits
     flags
{% endhighlight %}

ARM 所支持的模式定义如下：

{% highlight bash %}
#if defined(__KERNEL__) && defined(CONFIG_CPU_V7M)
/*
 * Use 0 here to get code right that creates a userspace
 * or kernel space thread.
 */
#define USR_MODE        0x00000000
#define SVC_MODE        0x00000000
#else
#define USR_MODE        0x00000010
#define SVC_MODE        0x00000013
#endif
#define FIQ_MODE        0x00000011
#define IRQ_MODE        0x00000012
#define MON_MODE        0x00000016
#define ABT_MODE        0x00000017
#define HYP_MODE        0x0000001a
#define UND_MODE        0x0000001b
#define SYSTEM_MODE     0x0000001f
#define MODE32_BIT      0x00000010
#define MODE_MASK       0x0000001f
{% endhighlight %}

代码中调用 compare_cpu_mode_with_primary 宏对 r4 寄存器进行带优先级的比较
操作，如果比较的结果不等于零那么就直接退出函数；如果等于零，那么就继续执行函数，
从 compare_cpu_mode_with_primary 宏的定义可知，它将 r4 与 r4 寄存器进行对比，
对比的值一定等于 0， 所以函数继续执行，接下来函数调用 cmp 指令，将 r4 的值
与 HYP_MODE 模式进行对比，确定当前模式是否是 HYP_MODE，如果是，那么就继续执行
函数；如果不是，则直接返回。使用 GDB 实际测试结果如下：

{% highlight bash %}
(gdb) target remote :1234
Remote debugging using :1234
_text () at arch/arm/boot/compressed/head.S:161
161			.endr
(gdb) b BS_X
Note: breakpoint 1 also set at pc 0x3680.
Breakpoint 2 at 0x3680: file arch/arm/boot/compressed/hyp-stub.S, line 97.
(gdb) c
Continuing.

Breakpoint 1, __hyp_stub_install_secondary ()
    at arch/arm/boot/compressed/hyp-stub.S:97
97		mrs	r4, cpsr
(gdb) n
98		and	r4, r4, #MODE_MASK
(gdb) n
104		compare_cpu_mode_with_primary	r4, r5, r6, r7
(gdb) n
105		retne	lr
(gdb) n
116		cmp	r4, #HYP_MODE
(gdb) info reg
r0             0x0                 0
r1             0x0                 0
r2             0x0                 0
r3             0x0                 0
r4             0x13                19
r5             0x0                 0
r6             0x0                 0
r7             0x0                 0
r8             0x0                 0
{% endhighlight %}

从上面可知，r4 所存储的当前模式不是 HYP 模式，所以放弃进入 HYP 模式。接下来函数
直接返回。接着函数返回之后，函数继续在 head.S 中继续执行如下代码：

{% highlight bash %}
                mov     r7, r1                  @ save architecture ID
                mov     r8, r2                  @ save atags pointer


#ifndef CONFIG_CPU_V7M
                /*
                 * Booting from Angel - need to enter SVC mode and disable
                 * FIQs/IRQs (numeric definitions from angel arm.h source).
                 * We only do this if we were in user mode on entry.
                 */
                mrs     r2, cpsr                @ get current mode
                tst     r2, #3                  @ not user?
                bne     not_angel
                mov     r0, #0x17               @ angel_SWIreason_EnterSVC
 ARM(           swi     0x123456        )       @ angel_SWI_ARM
 THUMB(         svc     0xab            )       @ angel_SWI_THUMB
not_angel:
                safe_svcmode_maskall r0
                msr     spsr_cxsf, r9           @ Save the CPU boot mode in
                                                @ SPSR
#endif
{% endhighlight %}

由于 uboot 结束后，会将 architecture ID 存放在 r7 寄存器，将 uboot 的 ATAG
参数的指针存放在 r8 寄存器里。于是代码中调用 mov 指令将 r7 的值存储到 r1 寄存器里，
将 r8 寄存器的值存储到 r2 寄存器里。由于本实践过程中，CONFIG_CPU_V7M 宏没有打开，
那么继续执行下一条指令是 "mrs r2, cpsr"， 这条指令将 CPSR 寄存器的值存储到 r2 寄存器
内，然后调用 tst 指令将 r2 寄存器的值与立即数 3 相与，如果相与的结果不等于 0， 那么
表示当前 CPU 所处的模式不是 User 模式，那么跳转到 not_angel 标签处继续执行；
如果相与的结果等于零，那么 CPU 处于 User 模式，那么调用 swi 指令直接进入 SVC 模式。
这段代码的主要任务就是如果当前模式是 User 模式，那么从 Angel 启动，在启动之前，
需要进入 SVC 模式，并关闭所有的 FIQs/IRQs 中断。接着调用 safe_svcmode_maskall
宏，接下来分析 safe_svcmode_maskall 宏，代码如下：

{% highlight bash %}
/*
 * Helper macro to enter SVC mode cleanly and mask interrupts. reg is
 * a scratch register for the macro to overwrite.
 *
 * This macro is intended for forcing the CPU into SVC mode at boot time.
 * you cannot return to the original mode.
 */
.macro safe_svcmode_maskall reg:req
#if __LINUX_ARM_ARCH__ >= 6 && !defined(CONFIG_CPU_V7M)
        mrs     \reg , cpsr
        eor     \reg, \reg, #HYP_MODE
        tst     \reg, #MODE_MASK
        bic     \reg , \reg , #MODE_MASK
        orr     \reg , \reg , #PSR_I_BIT | PSR_F_BIT | SVC_MODE
THUMB(  orr     \reg , \reg , #PSR_T_BIT        )
        bne     1f
        orr     \reg, \reg, #PSR_A_BIT
        badr    lr, 2f
        msr     spsr_cxsf, \reg
        __MSR_ELR_HYP(14)
        __ERET
1:      msr     cpsr_c, \reg
2:
#else
/*
 * workaround for possibly broken pre-v6 hardware
 * (akita, Sharp Zaurus C-1000, PXA270-based)
 */
        setmode PSR_F_BIT | PSR_I_BIT | SVC_MODE, \reg
#endif
.endm
{% endhighlight %}

由于本实践内容符合 __LINUX_ARM_ARCH__ 大于 6，而且 CONFIG_CPU_V7M 宏没有
定义，所以宏执行的代码为上部。宏首先执行 "mrs \reg, cpsr" 指令，根据调用宏处可知，
宏将 CPSR 的值存储到 r0 寄存器中，然后将 r0 寄存器的值与 HYP_MODE 宏进行异或
操作，结果存储到 r0 寄存器内，然后调用 tst 指令将 r0 寄存器的值与 MODE_MASK
进行与操作, 最后调用 bic 指令清除掉 MODE_MASK 对应的位，这样 r0 中模式位就全部
清零。接着调用 orr 指令将 (PSR_I_BIT | PSR_F_BIT | SVC_MODE) 的值与 r0 寄存器
的值相与之后存储到 r0 寄存器中。根据 CPSR 寄存器的布局可知：

{% highlight bash %}
CPSR：

  32        27         25     20        16        10        5        0
  +-+-+-+-+-+----------+-+----+---------+---------+-+-+-+-+-+--------+
  | | | | | |          | |    |         |         | | | | | |        |
  |N|Z|C|V|Q| IT[1:0]  |J|    | GE[3:0] | IT[7:2] |E|A|I|F|T| M[4:0] |
  | | | | | |          | |    |         |         | | | | | |        |
  +-+-+-+-+-+----------+-+----+---------+---------+-+-+-+-+-+--------+
  | <-----> |                                       | <-> |
   Condition                                       Mask bits
     flags
{% endhighlight %}

PSR_I_BIT 对应的是 CPSR 的 I 位，这个位用于 IRQ 的掩码位；PSR_F_BIT 对应的是
CPSR 的 F 位，该位用于 FIQ 的掩码。这两位只要置位，那么对应的中断就断就会被屏蔽。
或上 SVC_MODE 就是将模式设置为 SVC 模式。orr 指令执行的结果不等于零，那么跳转
到 1 标签处，1 标签处调用 "msr cpsr_c, \reg" ，这里 cpsr_c 代表 CPSR 的低
8 位，也就是 CPSR 的控制位。这样 CPU 就进入屏蔽了 IRQ，FRQ 的 SVC 模式。
调用完 safe_svcmode_maskall 之后，head.S 调用 "msr spsr_cxsf, r9" 将 r9
寄存器的值存储到 spsr_cxsf，这里 spsr_cxsf 代表 SPSR 寄存器的 C 域， X 域，
S 域， 和 F 域。由于在设置进入 SVC 模式之前，就将 CPSR 寄存器的值存储到 r9
寄存器，所以 r9 寄存器保存了 CPU 最开始的模式。最后将原始的 CPU 模式存储到了
SPSR 寄存器中。

接下来，head.S 将找到物理地址的起始地址，这个时候 MMU 是没有打开的，这个时候是
忽略任何地址对齐和偏移。head.S 选择最开始的 128MB 处作为对齐地址，然后将
zImage 放在这物理地址起始处，这 128MB 就是用来专门存放 zImage 镜像的。具体
代码如下：

{% highlight bash %}
#ifdef CONFIG_AUTO_ZRELADDR
                /*
                 * Find the start of physical memory.  As we are executing
                 * without the MMU on, we are in the physical address space.
                 * We just need to get rid of any offset by aligning the
                 * address.
                 *
                 * This alignment is a balance between the requirements of
                 * different platforms - we have chosen 128MB to allow
                 * platforms which align the start of their physical memory
                 * to 128MB to use this feature, while allowing the zImage
                 * to be placed within the first 128MB of memory on other
                 * platforms.  Increasing the alignment means we place
                 * stricter alignment requirements on the start of physical
                 * memory, but relaxing it means that we break people who
                 * are already placing their zImage in (eg) the top 64MB
                 * of this range.
                 */
ENTRY(BS_debug)
                mov     r4, pc
                and     r4, r4, #0xf8000000
                /* Determine final kernel image address. */
                add     r4, r4, #TEXT_OFFSET
#else
                ldr     r4, =zreladdr
#endif
{% endhighlight %}

首先调用代码 "mov, r4, pc"，将当前 CPU 执行的地址存储到 r4 ，然后在将 0xf8000000
的值与 r4 相与达到对齐的作用，确保 r4 按 128M 对齐，然后将 r4 寄存器的值加上
TEXT_OFFSET，TEXT_OFFSET 定义在 arch/arm/Makefile 中，如下：

{% highlight bash %}
# Text offset. This list is sorted numerically by address in order to
# provide a means to avoid/resolve conflicts in multi-arch kernels.
textofs-y       := 0x00008000


# The byte offset of the kernel image in RAM from the start of RAM.
TEXT_OFFSET := $(textofs-y)
{% endhighlight %}

从上面可以看出，ARM 32 默认的 TEXT_OFFSET 设置为 0x00008000, 这个地址就是内核
的解压地址。接着执行如下代码：

{% highlight bash %}
                /*
                 * Set up a page table only if it won't overwrite ourself.
                 * That means r4 < pc || r4 - 16k page directory > &_end.
                 * Given that r4 > &_end is most unfrequent, we add a rough
                 * additional 1MB of room for a possible appended DTB.
                 */
                mov     r0, pc
                cmp     r0, r4
                ldrcc   r0, LC0+32
                addcc   r0, r0, pc
                cmpcc   r4, r0
                orrcc   r4, r4, #1              @ remember we skipped cache_on
                blcs    cache_on
{% endhighlight %}

运行到这里，首先获得 PC 寄存器的值，然后调用 "cmp r0, r4", 这里执行这条命令的含义
是，如果 r0 < r4, 那么接下来将执行带 cc 后缀的指令，如果 r0 > r4，那么就执行
cache_on 宏。此时从上面的分析可知，r0 < r4， 开发者们可以通过实际 GDB 调试代码
可验证。接下在，将 LC0+32 对应的内容拷贝到 r0 寄存器。 LC0 的定义如下：

{% highlight bash %}
                .align  2
                .type   LC0, #object
LC0:            .word   LC0                     @ r1
                .word   __bss_start             @ r2
                .word   _end                    @ r3
                .word   _edata                  @ r6
                .word   input_data_end - 4      @ r10 (inflated size location)
                .word   _got_start              @ r11
                .word   _got_end                @ ip
                .word   .L_user_stack_end       @ sp
                .word   _end - restart + 16384 + 1024*1024
                .size   LC0, . - LC0
{% endhighlight %}

LC0 定义为一个对象，其位于 .text section 内，其布局如上，LC0 作为此阶段一个简单
的页表。为程序提供了各个 section 的位置。 所以 LC0 偏移 32 的位置
对应的内容是 "_end - restart + 16384 + 1024*1024" ，这里的含义是此阶段 vmlinux
的结束地址之后的 1M + 16K 的地址存放在 r0 寄存器中。接着对比 r4 和 r0 的值，如果
此时 r4 < r0， 那么执行 "orrcc r4, r4, #1" 命令；反之执行 "blcs cache_on"。有上面
的分析可知，r4 < r0，所以将 r4 的地址加 1 跳过 cache_on. 实际 GDB 运行效果如下：

{% highlight bash %}
(gdb) target remote :1234
Remote debugging using :1234
_text () at arch/arm/boot/compressed/head.S:161
161			.endr
(gdb) b BS_debug
Breakpoint 1 at 0xac: file arch/arm/boot/compressed/head.S, line 251.
(gdb) c
Continuing.

Breakpoint 1, BS_debug () at arch/arm/boot/compressed/head.S:251
251			mov	r0, pc
(gdb) n
252			cmp	r0, r4
(gdb) n
253			ldrcc	r0, LC0+32
(gdb) n
254			addcc	r0, r0, pc
(gdb) n
255			cmpcc	r4, r0
(gdb) n
256			orrcc	r4, r4, #1		@ remember we skipped cache_on
(gdb) n
257			blcs	cache_on
(gdb) n
restart () at arch/arm/boot/compressed/head.S:259
259	restart:	adr	r0, LC0
(gdb)
{% endhighlight %}
