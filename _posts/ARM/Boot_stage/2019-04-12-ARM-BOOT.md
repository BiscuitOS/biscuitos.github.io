---
layout:             post
title:              "从第一行代码实践/Debugging ARM linux 5.0 内核"
date:               2019-04-12 07:00:30 +0800
categories:         [MMU]
excerpt:            Debugging ARM Linux from first code.
tags:
  - MMU
---

> [GitHub Bootstrap ARM](https://github.com/BiscuitOS/Bootstrap_arm)
>
> Email: BuddyZhang1 <buddy.zhang@aliyun.com>
>
> Info: ARM 32 -- Linux 5.0

# 目录

> - [简介](#简介)
>
> - [实践](#实践)
>
> - [附录](#附录)

--------------------------------------------------------------
<span id="简介"></span>

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/IND00000A.jpg)

# 简介

> - [文章简介](#文章简介)
>
> - [实践原理](#实践原理)
>
> - [实践准备](#实践准备)
>
> - [实践选择](#实践选择)

##### <span id="文章简介">文章简介</span>

俗话说的好 “纸上谈兵终觉浅，绝知此事要躬行”，对于 Linux 内核的学习同样适用，各位
开发者是否看遍了各种经典典籍，但还是对 Linux 不能运用自如。不是开发者不努力，而是
学习 Linux 内核的方法不合适。如何让开发者更有效的学习 Linux 内核其实是作者一直
考虑的问题，经过多年的 Linux 内核开发学习经验，写下了这篇文章和各位开发者分享
如何有效的学习 Linux 内核。

内核实践是作者在 Linux 内核学习中最提倡的学习论，即面对一个全新 Linux 原理或问题，
开发者首先应该做的是如何在有限的实践平台上将原理或问题付诸实践，然后从实践中获得对
Linux 原理和问题的自我认知，有了对问题的自我认知之后再回过头来学习问题对应的原理，
此时，再将原理的认知和实践的认知再投入新的实践中，加入对问题的疑问和想法进行更多的
实践，又从中得到新的认知，有了新的认知之后就产生最原始的求知欲。有了求知欲是一件好
事，凭着这股求知欲去知识里寻找真理，最后问题得到解决，开发者也就学会自主学习的能力，
在经过长期习惯的积累，开发者也就掌握了问题解决的原始能力。

说这么多，那么进入本文的正题。操作系统运作的原理可以简单的总结为 CPU 将位于内存中
的指令和数据加载到 CPU 中运行，重复这个动作，一个操作系统就工作起来。那么可以考虑
这么一个问题，开发者手头正好有一个 Linux 5.x 的内核，想在 ARM 上运行，那么只需将
Linux 5.x 的源码编译汇编成对应平台的指令，然后加载到内存，接着 CPU 读取这些指令，
这样 Linux 就在 ARM 上运行起来了，对一个操作系统就是这么简单的原理工作起来的。
那么本文主要想做的事就是，开发者可以从第一行代码开始编写，然后让这行代码编译汇编
之后加载到内存，之后由 ARM CPU 调用执行，再重复刚刚的操作，这样一行一行代码的添加，
Linux 内核就编写和调试出来了。因此，本文就是用于讲解如何从第一行代码开始，如何编写并
调试运行在 ARM 上的 Linux 5.x。

本文适合作为 Linux 5.0 ARM boot 阶段源码实践教程，也适合操作系统从原点实践教程。

##### <span id="实践原理">实践原理</span>

Linux 源码采用 Kbuild 进行源码的编译汇编，并链接生成可在对应硬件平台上运行的
二进制文件。Linux 从源码到目标平台运行的过程经历了下图所示的过程：

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/BOOT000000.png)

如上图所示，Linux 源码经过 Kbuild 编译系统的编译、汇编、链接之后在源码目录生成
ELF 目标文件 vmlinux。由于 vmlinux 包含了各种数据段，此时还不能在 ARM 上直接运行，
于是使用 OBJCOPY 工具将不必要的段丢弃之后，生成二进制文件 Image。此时的 Image
是可以在 ARM CPU 上直接运行的，但此时 Image 的体积太大，不利于一些历史原因，所以
将 Image 进行压缩，生成 piggy_data 文件，由于最新的内核支持多种压缩方式，所以抛弃
以前的 piggy.gz 叫法。由于压缩之后的文件不能直接在 ARM CPU 上运行，所以需要将压缩
后的内核想办法在内存中解压并能让 ARM CPU 能正确执行解压之后的内存，这部分功能称为
bootstrap，为了让压缩之后的内核具有 bootstrap 功能，于是将 piggy_data 文件包含到
一个汇编文件 piggy.S 里面，然后将 piggy.S 与 bootstrap 功能的源码进行编译、汇编、
链接生成 ELF 文件 vmlinux，开发者要注意，此处的 vmlinux 和之前提到的 vmlinux 不是
同一个文件。此时 vmlinux 由于包含了很多不必要的数据段，不能在 ARM CPU 上直接运行，
于是采用了之前的办法，使用 OBJCOPY 工具将不必要的段都丢弃，最后生成可以在 ARM CPU
上运行的二进制文件 zImage。在实际工程实践中，会遇到 uImage，这个二进制文件是通过
uboot 提供的工具，将 zImage 的头部做了修改，以便于 uboot 加载，但 uImage 和内核
没有多大的关系，所以这里不做讨论。更多详细的细节，请参考文档：

> [Bootstrap vmlinux]()

什么位置是 Linux 在 ARM CPU 上运行的起点呢，通过上面的分析可以知道，Linux 最终与
zImage 的形式加载到内存上直接运行，这个阶段的主要任务就是将真正的内核解压到指定
位置，在将 ARM CPU 指向真正内核运行。所以 Linux 加载到 ARM CPU 运行的起点就是
vmlinux 的 bootstrap 功能代码，其源码位于 arch/arm/boot/compressed 目录下，因此
本实践教程以此为原点进行讲解。

##### <span id="实践准备">实践准备</span>

由于本实践是基于 ARM Linux 5.0，所以开发者还没有搭建源码开发环境，可以参考如下文档：

> [ARM Linux 5.0 内核源码开发环境搭建](https://biscuitos.github.io/blog/Linux-5.0-arm32-Usermanual/)

实践过程中需要用的原理，芯片手册，文档等，请参考如下链接：

> - [ARM Architecture Reference Manual](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/ARM/ARM_Architecture_Reference_Manual.pdf)
>
> - [ARMv7 Architecture Reference Manual](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/ARM/ARMv7_architecture_reference_manual.pdf)
>
> - [Vexpress-a9 Reference Manual](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/ARM/vexpress-a9.pdf)
>
> - [ARM 汇编实践手册](https://biscuitos.github.io/blog/MMU-ARM32-ASM-index/)
>
> - [ARM 汇编指令快速查询](https://biscuitos.github.io/blog/MMU-ARM32-ASM-index/#ARM_INS_LIST)
>
> - [ARM Debugging Usermanual](https://biscuitos.github.io/blog/BOOTASM-debuggingTools/)

##### <span id="实践选择">实践选择</span>

本文提供了三种实践策略，开发者需要选择其中一种策略进行实践。

###### 策略一

这个策略主要面向对 boot 阶段 ARM Linux 源码实践的开发者，在这个策略中，提供原始
的源码文件进行实践，开发者无需做其他步骤，直接进入下一个章节。

###### 策略二

这个策略主要是由于 arch/arm/boot/compressed 目录下兼容了很多平台，导致源码臃肿，
作者提供了一个干净的源码，里面只包含实际运行的代码，不包含其他无用代码。需要使用这个
策略的开发者首先获得 ARM linux 5.0 开发环境，之前提过制作方法。然后进入到源码的
arch/arm/boot/ 目录，将原始的 compressed 目录删除，然后使用如下命令：

{% highlight bash %}
cd arch/arm/boot/
rm -rf compressed/

git clone https://github.com/BiscuitOS/Bootstrap_arm.git compressed
{% endhighlight %}

###### 策略三

这个策略比较策底，从第一行代码开始编写。其做法与策略二类似，请参考如下步骤：

{% highlight bash %}
cd arch/arm/boot/
rm -rf compressed/

git clone https://github.com/BiscuitOS/Bootstrap_arm.git compressed
cd compressed
git reset --hard v0.0.1
{% endhighlight %}

--------------------------------------------------------------
<span id="实践"></span>

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/kernel/IND00000G.jpg)

# 实践

> - [最小实践](#最小实践)

### 最小实践

本小节讲解如何进行最小实践。无论采用何种实践策略，接下来的实践内容都适用。做好的前期
准备之后，开发者首先在源码中加入断点，以方便断点调试。源码位于 arch/arm/boot/compressed/head.S

{% highlight bash %}
 AR_CLASS(      .arm    )
start:
                .type   start,#function
                .rept   7
                .endr
                W(b)    1f

1:
ENTRY(BS_debug)
                mov     r1, #90

                .text
{% endhighlight %}

接着根据 BiscuitOS/output/linux-5.0-arm32/README.md 提供的编译说明，按如下命令
编译内核：

{% highlight bash %}
make ARCH=arm CROSS_COMPILE=BiscuitOS/output/linux-5.0-arm32/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi- -j4
{% endhighlight %}

编译完毕之后，继续参照 BiscuitOS/output/linux-5.0-arm32/README.md 提供的编译说明，
打开两个新的终端，第一个终端中输入如下命令：

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-arm32
./RunQemuKernel.sh debug
{% endhighlight %}

第二个终端中输入如下命令：

{% highlight bash %}
BiscuitOS/output/linux-5.0-arm32/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi-gdb -x BiscuitOS/output/linux-5.0-arm32/gdb/gdb_zImage
(gdb) b BS_debug
(gdb) c
(gdb) info reg
{% endhighlight %}

实际运行的效果如下：

![MMU](https://raw.githubusercontent.com/EmulateSpace/PictureSet/master/BiscuitOS/boot/BOOT000000.png)

本实践中，节本调试方法就是这样，在后续的实践中，只介绍实践后的结果，实践过程在此处。
