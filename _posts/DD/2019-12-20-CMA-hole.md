---
layout: post
title:  "CMA 碎片问题研究"
date:   2019-12-20 09:23:30 +0800
categories: [HW]
excerpt: CMA hole.
tags:
  - [CMA]
---

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L0.PNG)

> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

## 目录

> - [CMA 碎片原理](#A0)
>
>   - [CMA 碎片问题描述](#A0001)
>
>   - [CMA 碎片问题原因](#A0002)
>
>   - [CMA 碎片解决办法](#A0003)
>
> - [实践部署](#B0)
>
>   - [实践基础部署](#B01)
>
>   - [实践用例部署](#B02)
>
>   - [实践编译部署](#B03)
>
>   - [实践运行部署](#B04)
>
>   - [实践源码分析](#B05)
>
> - [研究分析](#C0)
>
> - [实践结论](#D0)
>
> - [附录](#Z0)

----------------------------------

<span id="A0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000P.jpg)

#### CMA 碎片原理

> - [CMA 碎片问题描述](#A0001)
>
> - [CMA 碎片问题原因](#A0002)
>
> - [CMA 碎片解决办法](#A0003)

-----------------------------------

#### <span id="A0001">CMA 碎片问题描述</span>

CMA 是 linux 基于 Buddy 内存分配器实现的一种用于分配连续物理内存的分配器，
其出现是为了满足日益增长的视频转码、AI 视频处理等业务对连续物理内存的迫切
需求，CMA 的出现极大的满足了这类业务的需求，但同时也带来的诸多问题，例如
本文研究的碎片问题。

CMA 内存的分配器通过 bitmap 进行管理，一个 bit 代表一个 4K 大小的连续物理
内存，CMA 将分配的 4K 物理内存块在对应的 bit 上置位，而在为分配的 4K 物理
内存块对应的 bit 上清零。因此 CMA 分配物理内存时通过再 bitmap 找到符合
要求的空闲区域，当释放内存的时候就将对于的 bit 清零即可，简单高效。

基于上面的分配策略，不难发现，每次申请物理内存的时候，CMA 总是从 bitmap
的其实地址开始查找第一块可用的物理内存区块。这样的逻辑也没有什么问题，
但随着时间的增长，CMA 经过无数次的分配和释放操作之后，CMA 内存区块被
分成了零散的多块区域，最大可用连续物理内存也变的很小。例如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000039.png)

CMA 在未使用的情况下，最长可用物理内存即 CMA 区块的长度。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000040.png)

CMA 经过无数次分配和释放操作之后，CMA 内存区块已经变得零零碎碎，
最长可用物理内存已经变得很短很短。

在长时间运行的情况下，系统会遇到一个问题，当系统需要分配的连续物理
内存块不算太长，但已经超过当前 CMA 可分配最长物理内存区块，那么这将
导致一个很严重的问题: CMA 分配失败。这里将这个问题成为 CMA 碎片问题。
开发者可以参考链接中的内存实践并浮现图片中涉及的问题:

> - [CMA 碎片问题实践与复现](#B0)

-----------------------------------

#### <span id="A0002">CMA 碎片问题原因</span>

CMA 是基于 buddy 的连续物理内存分配器，从这个定义就可以知道，CMA 分配
的物理内存是不能将空闲的物理块进行迁移合并，基于这个原理，如果遇上下面
这种情况，碎片很容易长生:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000060.png)

如上图，"1)" 中 CMA 原有 1M 的可用连续物理区块; "2)" 系统首先申请了一块
相对较大的内存区块 A，接着有申请一块小的内存区块，根据 CMA 的分配策略，
它会从 bitmap 的起始处开始找符合要求大小的物理内存区块，正巧区块 A 之后
就是符合要求的物理内存区块，于是分配给 B; "3)" 的时候，A 使用完毕之后，
就将 A 归还 CMA，但此时 B 还在使用，因此 CMA 原先可分配 1M 的能力就失去了，
结果现在最长申请只能是 B 两边任意一块，这样 CMA 碎片就产生了。

-----------------------------------

#### <span id="A0003">CMA 碎片解决办法</span>

由于 CMA 的物理内存连续性，碎片问题目前还不能得到根治，但可采用一下办法
来缓解 CMA 碎片问题，具体思路如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000061.png)

将 CMA 分作多个区域，例如上图将 CMA 分作了 3 个区域，第一个区域用于分配
小块的连续物理内存，第二个区块用于分配中等区块的连续物理内存，第三块用
于分配大块的连续物理内存，这样做的好出如下图所示:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000062.png)

如上图，将 CMA 分作多个块，其中就有 "X Area"、"XX Area" 和 "XXX Area",
"1)" 的时候，"X Area" 已经分配了三块，"XX Area" 分配了两块，"XXX Area"
分配了五块; "2)" 的时候，"X Area" 释放了一块，"XX Area" 释放了一块，
"XXX Area" 释放了两块。"3)" 的时候，需要分享一块大小为 "X" 的物理块，
那么 CMA 就去 "X Area" 区域中找到一块可用的位置进行分配. 接着需要
分配一块大小为 "XX" 的物理内存区块，此时 CMA 并未去 "X Area" 或者
"XX Area" 之前的区域中进行查找，而是直接去 "XX Area" 中进行查找，
查找到可用位置之后就进行分配。同理 "XXX" 也去 "XXX Area" 中进行
查找分配。经过长时间的运行 CMA 会变得的整整齐齐，保持着最长分配
连续物理内存长度。

基于上面的分析得出的结果，为了缓解 CMA 分配器碎片问题，我决定
对 CMA 内存分配器进行改造，请参考如下章节:

> - [CMA 碎片问题改造研究](#C0)

----------------------------------

<span id="B0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L.jpg)

## 实践部署

> - [实践基础部署](#B01)
>
> - [实践用例部署](#B02)
>
> - [实践编译部署](#B03)
>
> - [实践运行部署](#B04)
>
> - [实践源码分析](#B05)

---------------------------------

#### <span id="B01">实践基础部署</span>

本文支持在 BiscuitOS 上实践 CMA 碎片问题，如果还没有搭建 BiscuitOS 
开发环境，可以下列文章:

> - [BiscuitOS 快速部署(基于 linux 5.0)](https://biscuitos.github.io/blog/Linux-5.0-arm32-Usermanual/)

----------------------------

#### <span id="B02">实践用例部署</span>

如果已经搭建好 BiscuitOS 开发环境，本文实践部署如下:

{% highlight c %}
cd BiscuitOS
make linux-5.0-arm32_defconfig
make menuconfig 
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000003.png)

选择 "Package" 并进入二级菜单.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000041.png)

选择 "CMA: Contiguous Memory Allocator --->" 并进入二级菜单.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000042.png)

选择 "CMA Debris issue Application" 和 "CMA: Debris issue Device 
Driver Module" 并保存退出。接着使用如下命令:

{% highlight c %}
make
cd BiscuitOS/output/linux-5.0-arm32/package/
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000007.png)

------------------------------------

#### <span id="B03">实践编译部署</span>

为了复现 CMA 碎片问题，这里准备了对应的驱动程序和应用程序，
开发者参考下面步骤进行编译安装:

> - [驱动程序](#B0001)
>
> - [应用程序](#B0002)

-------------------------------------

###### <span id="B0001">驱动程序</span>

驱动程序用于为用户空间应用程序提供 CMA 申请的借口，其使用如下:

{% highlight c %}
cd BiscuitOS/output/linux-5.0-arm32/package/CMA_debris_module-0.0.1
make prepare
make download
{% endhighlight %}

执行完上面的命令之后，BiscuitOS 会下载指定的文件，如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000047.png)

获得上面的文件之后，开发者首先根据 "00001-CMA-special-areas.patch" 补丁
中的内容，对内核进行手动补丁或自动补丁，其修改内容如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000044.png)

从补丁的内容可以看出，首先将 "dma_alloc_from_contiguous" 和
"dma_release_from_contiguous" 两个函数使用 "EXPORT_SYMBOL()" 宏
进行导出，以便供外部模块使用。接着在 "mm/cma.c" 文件中添加了
一个函数 "find_cma_by_name()" 其作用是通过名字直到指定的 cma
区块对应的结构体. 接着是 "default.dts" 文件，该文件用户描述
该驱动的 DTS 节点以及 CMA 区块的配置信息，如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000045.png)

开发者参考上面的内容添加到内核的 DTS 文件中，例如本例子中
使用的 DTS 位于:

{% highlight c %}
vi BiscuitOS/output/linux-5.0-arm32/linux/linux-5.0/arch/arm/boot/dts/vexpress-v2p-ca9.dts
{% endhighlight %}

开发者参考上面的 DTS 之后，在项目的 DTS 文件中找到 reserved-memory 节点，
然后向该节点中分别添加 "linux,cma" 和 "BiscuitOS_cma" 两个节点，其节点
属性与图中的配置一致。接着在 reserved-memory 节点之外增加 "BiscuitOS_CMA"
节点，其属性和图中一致。最后打完补丁和添加完 patch 之后，开发者需要重新
编译内核，可以参考如下命令:

{% highlight c %}
cd BiscuitOS/output/linux-5.0-arm32/linux/linux-5.0/
make ARCH=arm CROSS_COMPILE=BiscuitOS/output/linux-5.0-arm32/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi- -j4
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000046.png)

接着编译驱动和安装模块到 BiscuitOS，使用如下命令:

{% highlight c %}
cd BiscuitOS/output/linux-5.0-arm32/package/CMA_debris_module-0.0.1
make clean
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000043.png)

执行完上面的命令之后，驱动已经成功安装到 BiscuitOS，接着只要在
BiscuitOS 系统运行的时候安装就行。接下来是安装驱动对应的应用程序。

-----------------------------------

###### <span id="B0002">应用程序</span>

应用程序与驱动程序配合，目的是在 BiscuitOS 系统上模拟一个随机分配
和释放 CMA，每次操作 CMA 大小也是随机的，以便进行压力测试并复现碎片
导致 CMA 分配失败的情况。开发者首先按照下列步骤部署应用程序:

{% highlight c %}
cd BiscuitOS/output/linux-5.0-arm32/package/CMA_debris_app-0.0.1
make download
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000048.png)

在获得源码之后，开发者继续执行如下命令将应用程序源码进行编译、安装
和打包到 BiscuitOS 系统里:

{% highlight c %}
make clean
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000049.png)

---------------------------------

#### <span id="B04">实践运行部署</span>

在准备好驱动和应用程序之后，接下来就是在 BiscuitOS 上面复现 CMA 碎片
问题。开发者使用如下命令启动 BiscuitOS:

{% highlight c %}
cd BiscuitOS/output/linux-5.0-arm32/
./RunBiscuitOS.sh
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000050.png)

接着安装驱动:

{% highlight c %}
cd lib/modules/5.0.0/extra/
insmod cma.ko
lsmod
ls -l /dev/BiscuitOS_CMA
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000051.png)

安装完毕驱动之后，可以在 "/sys/bus/platform/devices/BiscuitOS_CMA" 目录下
查看当前 CMA bitmap 使用情况，如下图:

{% highlight c %}
cd /sys/bus/platform/devices/BiscuitOS_CMA
cat bitmap
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000052.png)

由上图可知，当未进行 CMA 初始化时，CMA area 的 bitmap 全都可用，
上图为一块 8M 的 CMA，所以最长可用连续物理内存为 8M. 测试还可以
通过下面的命令查看与 CMA 相关的信息:

{% highlight c %}
cat /proc/meminfo
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000053.png)

由上图可知，"CmaTotal" 说明系统 CMA 大小为 16384KB，即 16M, "CmaFree"
说明当前可用 CMA 的总数为 14592KB, 但不代表连续的物理内存为 14592KB. 

接下来就是运行测试程序，测试程序会不停的分配或释放随机大小的 CMA
物理块，直到失败为止，并打印分配的次数和释放的次数。具体命令如下:

{% highlight c %}
CMA_debris_app-0.0.1 &
{% endhighlight %}

可以使用压后台的方式，开发者可以动态查看 /proc/meminfo 下面 CMA
的使用情况。如下命令:

{% highlight c %}
cat /proc/meminfo | grep Cma
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000054.png)

从上图看出了测试程序运行的时候，抓取的 "/proc/meminfo" 的瞬间数据，
CMA 使用从在 "8836KB -- 7564KB" 之间变换，但 CMA 的总数还未耗尽。
最后测试程序失败，总共执行了 16687 次分配和 16550 次释放，此时使用
命令打印出 CMA 的 bitmap 使用情况:

{% highlight c %}
cd /sys/bus/platform/devices/BiscuitOS_CMA
cat bitmap
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000055.png)

从上图已经很直白的看出 CMA 已经被碎片化了，最长连续物理内存为 44bits，
即 176KB 的连续物理内存。此时如果在运行测试程序，程序还可以运行，
运行之后的 bitmap 如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000056.png)

如上图，再次运行测试程序，程序一共进行了 10 次分配操作，CMA 可用的物理
内存又被耗尽不少，如果开发者不停运行测试程序，知道分配为 0 次，此时
bitmap 基本被耗尽，如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000057.png)

通过以上实践，已经完整展示了 CMA 碎片化带来的问题。

---------------------------------

#### <span id="B05">实践源码分析</span>

源码分作驱动部分和应用程序部分，驱动源码位于:

{% highlight c %}
BiscuitOS/output/linux-5.0-arm32/package/CMA_debris_module-0.0.1/CMA_debris_module-0.0.1/cma.c
{% endhighlight %}

应用程序源码位于:

{% highlight c %}
/xspace/OpenSource/BiscuitOS/BiscuitOS/output/linux-5.0-arm32/package/CMA_debris_app-0.0.1/CMA_debris_app-0.0.1/cma.c
{% endhighlight %}

驱动程序的主要通过应用程序 ioctl 发送命令 "CMA_MEM_ALLOCATE" 和
"CMA_MEM_RELEASE" 告诉驱动程序进行 CMA 分配和释放，驱动程序进而调用
"dma_alloc_from_contiguous()" 函数和 "dma_release_from_contiguous()" 函数
进行进行 CMA 的分配和释放动作。

在测试程序中定义了一个 CMA 分配长度数组，并调用随机函数生成随机索引
去访问这个数据，程序就使用这个数值作为分配和释放的依据，最后不断
重复申请和释放，直到 CMA 失败为止.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000058.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000059.png)


{% highlight c %}

{% endhighlight %}

----------------------------------

<span id="C0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000E.jpg)

## 研究分析

基于上述的实践和原理，本节重点介绍不同的文件路径长度导致不同的
内核策略，实践可以分成如下几类:

> - [路径名长度小于 EMBEDDED_NAME_MAX](#C01)
>
> - [路径名长度等于 EMBEDDED_NAME_MAX](#C02)
>
> - [路径名长度大于 EMBEDDED_NAME_MAX 小于 PATH_MAX](#C03)
>
> - [路径名长度等于 PATH_MAX](#C04)
>
> - [路径名长度大于 PATH_MAX](#C05)


--------------------------------------

#### <span id="C01">路径名长度小于 EMBEDDED_NAME_MAX</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000009.png)

在应用程序中修改文件路径长度为 32，如上图。编译安装之后，在内核源码
"getname_flags()" 添加相应的调试信息，以此跟踪内核处理逻辑, 修改如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000011.png)

{% highlight c %}
open_pathlen-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000010.png)

从运行的结果可以看出，文件路径名长度小于 EMBEDDED_NAME_MAX 并不需要
使用分离的 struct filename. 其路径名管理如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000001.png)

--------------------------------------

#### <span id="C02">路径名长度等于 EMBEDDED_NAME_MAX</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000012.png)

在应用程序中修改文件路径长度为 EMBEDDED_NAME_MAX，如上图。编译安装
之后，在内核源码 "getname_flags()" 添加相应的调试信息，以此跟踪内核
处理逻辑, 修改如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000014.png)

{% highlight c %}
open_pathlen-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000013.png)

从运行的结果可以看出，文件路径名长度等于 EMBEDDED_NAME_MAX 需要
使用分离的 struct filename. 其路径名管理如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000002.png)

--------------------------------------

#### <span id="C03">路径名长度大于 EMBEDDED_NAME_MAX 小于 PATH_MAX</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000015.png)

在应用程序中修改文件路径长度为 "EMBEDDED_NAME_MAX + 2"，如上图。编译安装
之后，在内核源码 "getname_flags()" 添加相应的调试信息，以此跟踪内核
处理逻辑, 修改如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000014.png)

{% highlight c %}
open_pathlen-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000016.png)

从运行的结果可以看出，文件路径名长度大于 EMBEDDED_NAME_MAX，但小于
PATH_MAX, 需要使用分离的 struct filename, 并且两次从用户空间读取的
长度不同。其路径名管理如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000002.png)

--------------------------------------

#### <span id="C04">路径名长度等于 PATH_MAX</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000017.png)

在应用程序中修改文件路径长度为 PATH_MAX，如上图。编译安装之后，
在内核源码 "getname_flags()" 添加相应的调试信息，以此跟踪内核
处理逻辑, 修改如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000014.png)

{% highlight c %}
open_pathlen-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000018.png)

从运行的结果可以看出，文件路径名长度等于 PATH_MAX 需要
使用分离的 struct filename, 但就算使用分离的 struct filename,
内核还是不能管理这么路径名长度为 PATH_MAX 的情况，直接返回
"ENAMETOOLONG".

--------------------------------------

#### <span id="C05">路径名长度大于 PATH_MAX</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000019.png)

在应用程序中修改文件路径长度为 PATH_MAX，如上图。编译安装之后，
在内核源码 "getname_flags()" 添加相应的调试信息，以此跟踪内核
处理逻辑, 修改如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000014.png)

{% highlight c %}
open_pathlen-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000020.png)

从运行的结果可以看出，文件路径名长度等于 PATH_MAX 需要         
使用分离的 struct filename, 但就算使用分离的 struct filename, 
内核只能从用户空间读取长度为 PATH_MAX 长度的内容，并且
内核还是不能管理这么路径名长度为 PATH_MAX 的情况，直接返回
"ENAMETOOLONG".

----------------------------------

<span id="D0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000F.jpg)

## 实践结论

从上面的实践最终可以得出以下结论:

> - 文件路径名长度不能超过 PATH_MAX
>
> - 最优文件路径名长度不能超过 EMBEDDED_NAME_MAX

-----------------------------------------------

# <span id="Z0">附录</span>

> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## 赞赏一下吧 🙂

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/HAB000036.jpg)
