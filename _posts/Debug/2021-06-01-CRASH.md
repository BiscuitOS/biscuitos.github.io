---
layout: post
title:  "内核核心转储: Kdump with kexec and crash"
date:   2021-06-01 06:00:00 +0800
categories: [HW]
excerpt: MMU Tools.
tags:
  - Tools
---

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L0.PNG)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI100100.png)

#### 目录

> - [内核核心转储介绍](#A)
>
> - [内核核心转储环境部署](#B)
>
> - [Crash 基础教程](#E)
>
>   - [Crash 报告信息分析](#E01)
>
>   - [Crash 寄存器约定与函数参数传递](#E00)
>
>   - [Crash 堆栈使用以及问题定位分析](#E02)
>
> - [Crash 经典案例之](#D)
>
>   - [Crash 经典案例值内存越界](#D0)
>
>   - [Crash 经典案例之空指针](#D1)
>
> - [留言与问题反馈](#ANS)
>
> - [附录/捐赠](#Z0)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="B"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000H.jpg)

#### 内核核心转储环境部署

内核核心转储环境部署指的是当内核发生 panic 时，可以借助一定的工具获得内核核心转储的内容，为后期的问题排除保留了问题现场和问题数据，这里简单的称为 kdump 为内核核心转储。内核和各发行版都提供了多种抓取内核 kdump 的工具和方法，其中包含了非发行版的 "kexec+crash" 方案，该方案可以运用于红帽和 Ubuntu 等发行版，也可以用于非标准发行版的 Linux 系统之上，那么这里就以 "kexec+crash" 方案进行讲解。为了让开发者更好的实践，本文提供了多种解决方案，建议开发者使用 BiscuitOS 方案进行实践. 本文以 Linux 5.0 X86_64 内核进行实践讲解, 具体如下:

> [通用内核方案](#B80)
>
> - [内核转储 Kdump 内核配置](#B00)
>
> - [内核转储 Kdump CMDLINE 配置](#B01)
>
> - [内核转储工具安装使用](#B03)
>
> - [内核转储 Kdump 抓捕过程](#C0)
>
> - [内核转储文件分析](#B09)
>
> - [Documentation for Kdump - The kexec-based Crash Dumping Solution](https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html)
>
> [标准发行版方案 (RedHat/Ubuntu)](#B82)
>
> - [Crash 内核配置](#B00)
>
> - [CRUB CMDLINE 配置](#B06)
>
> - [Crash 工具包安装](#B05)
>
> [BiscuitOS 方案 (推荐)](#B81)
>
> - [BiscuitOS 内核转储 Kdump 内核配置](#BX0)
>
> - [BiscuitOS 内核转储 CMDLINE 配置](#B02)
>
> - [BiscuitOS kexec-tools 部署](#B04)
>
> - [BiscuitOS 内核转储 kdump 抓捕过程](#C1)
>
> - [基于 Linux 5.0 X86_64 架构的 BiscuitOS 环境部署教程](https://biscuitos.github.io/blog/Linux-5.0-x86_64-Usermanual/)
>
> [QEMU 方案](#B83)
>
> [Libvirt/QEMU 虚拟化方案](#B84)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="B80"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000I.jpg)

#### 通用方案

通用方案指的是大多数 Linux 系统上都可以使用的抓取 kdump 方案。该方案的主要思路就是当内核发生 panic 的时候，可以使用 kexec 快速重启一个新的内核，以此给维护人员创造一个保留问题现场的机会，在进入新系统之后维护人员可以将内核 kdump 内容保存在指定位置，以此由于后期问题的排除。为了实现上面的功能，需要打开内核某些功能，并为 kexec 提供一个可以快速重启的内核，最后就是使用 crash 等工具进行问题排除, 那么开发者接下来参考下面的内容进行部署实践:

> - [内核转储 Kdump 内核配置](#B00)
>
> - [内核转储 Kdump CMDLINE 配置](#B01)
>
> - [kexec-tools 工具安装使用](#B03)
>
> - [内核转储 Kdump 抓捕过程](#C0)
>
> - [Documentation for Kdump - The kexec-based Crash Dumping Solution](https://www.kernel.org/doc/html/latest/admin-guide/kdump/kdump.html)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

###### <span id="B00">内核转储 Kdump 内核配置</span>

内核为了支持 kdump 功能，需要打开以下宏，以及不同的架构打开的宏不同:

###### CONFIG_KEXEC

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000630.png)

###### CONFIG_SYSFS

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000631.png)

###### CONFIG_DEBUG_INFO

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000632.png)

###### CONFIG_CRASH_DUMP

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000633.png)

###### CONFIG_PROC_VMCORE

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000634.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

###### <span id="B01">内核转储 Kdump CMDLINE 配置</span>

内核启用相关的内核配置之后，重新编译内核之后需要在 CMDLINE 中配置 crash 内核占用的内存大小，其语法如下:

{% highlight bash %}
crashkernel=<range1>:<size1>[,<range2>:<size2>,...][@offset]
range=start-[end]
{% endhighlight %}

通常可以在内核的 CMDLINE 中添加如下参数:

{% highlight bash %}
crashkernel=128M
{% endhighlight %}

CMDLINE 中该字段用于系统启动时为 kdump 预留 128M。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

---------------------------------

###### <span id="B03">内核转储工具安装使用</span>

内核转储工具包含了 gdb、crash 以及 kexec-tools 包，那么接下来本节用于讲解不同架构上工具的安装办法:

> [kexec-tools](#B031)
>
> [crash](#B032)
>
> [gdb](#B033)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

-----------------------------

###### <span id="B031">kexec-tools</span>

在调试过程中，经常需要重启内核以还原现场，进而复现某些问题予以追踪解决. 由于每一次的内核启动，都会伴随着一次的 boot 自检. 但是，对于已经启动过的同一内核，重复的 boot 自检完全没有必要，且造成了资源浪费. 此外，有时候需要使用一个小内核来启动一个大内核. 在这两种需求下，kexec 应运而生，kexec 是一款可以让您重新启动到一个新 Linux 内核的快速重新引导功能部件，不再必须通过固件和引导装载程序阶段，从而跳过序列中最长的部分，大大减少了重启时间. 对企业级系统而言，Kexec 大大减少了重启引起的系统宕机时间. 对内核和系统软件开发者而言，Kexec 帮助您在开发和测试成果时可以迅速重新启动系统，而不必每次都要再经历耗时的固件阶段. 通用 linux 系统中可用通过源码编译的方式安装 kexec-tools 工具，开发者可以参考如下步骤:

###### 源码下载

{% highlight bash %}
wget http://kernel.org/pub/linux/utils/kernel/kexec/kexec-tools.tar.gz
{% endhighlight %}

###### 源码解压

{% highlight bash %}
tar xf kexec-tools.tar.gz
{% endhighlight %}

###### X86_64 架构配置编译

{% highlight bash %}
cd kexec-tools-VERSION
./configure --build=x86_64-unknown-linux-gnu --host=x86_64-linux
make
make install
{% endhighlight %}

###### X86/I386 

{% highlight bash %}
cd kexec-tools-VERSION
./configure --build=x86_64-unknown-linux-gnu --host=i386-linux
make
make install
{% endhighlight %}

###### ARM64

{% highlight bash %}
cd kexec-tools-VERSION
./configure ARCH=arm64 --build=x86_64-unknown-linux-gnu --host=aarch64-linux LDFLAGS=-static
make
make install
{% endhighlight %}

###### ARM

{% highlight bash %}
cd kexec-tools-VERSION
./configure ARCH=arm --build=x86_64-unknown-linux-gnu --host=arm-linux-gnueabi LDFLAGS=-static
make
make install
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000635.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

---------------------------

###### <span id="B032">crash</span>

内核提供了多种内核转储分析工具，包括大家熟悉的 crash、Lcrash、Alicia 工具等，Crash 是由 Dave Anderson 开发和维护的一个内存转储分析工具。在没有统一标准的内存转储文件的格式的情况下，Crash 工具支持众多的内存转储文件格式。通用 linux 系统中可用通过源码编译的方式安装 kexec-tools 工具，开发者可以参考如下步骤:

###### 源码下载

{% highlight bash %}
git clone https://gitee.com/mirrors/crash.git
git clone https://github.com/crash-utility/crash.git
{% endhighlight %}

###### X86_64 架构配置编译

{% highlight bash %}
cd crash-utils
make target=X86_64 
make install
{% endhighlight %}

###### X86/i386 架构配置编译

{% highlight bash %}
cd crash-utils
make target=X86
make install
{% endhighlight %}

###### ARM64 架构配置编译

{% highlight bash %}
cd crash-utils
make target=ARM64
make install
{% endhighlight %}

###### ARM 架构配置编译

{% highlight bash %}
cd crash-utils
make target=ARM
make install
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000677.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

-------------------------------------

###### <span id="C0">内核转储 Kdump 抓捕过程</span>

在通用内核中，当发生内核 kdump 时可以使用 kexec-tools 重新启动到一个新 Linux 内核，维护者可以利用重启的新内核保存 kdump 内容. 为了 kexec 能够快速重启内核，因此需要准备一个 Dump-capture Kernel, Dump-capture Kernel 在不同的架构中表示不同，例如在 i386 或者 x86_64 中，可以是 vmlinux 或者 bzImage/vmlinuxz; 例如在 arm 架构中可以是 zImage, 而在 ARM64 架构中为 vmlinux/Image. 因此在通用内核中，可以参照如下命令在系统启动完毕之后运行 kexec 工具:

{% highlight bash %}
kexec -p <Dump-capture-kernel> --initrd=<initrd-for-Dump-capture-kernel> \
      --append=<CMDLINE>
{% endhighlight %}

当在系统中成功运行 kexec 中，接着可以手动触发内核 panic，以此查看功能的完成性:

{% highlight bash %}
echo c > /proc/sysrq-trigger
{% endhighlight %}

当使用该命令之后，内核将触发 panic，正常情况下内核将卡主不运行，当此时 kexec 会迅速重启一个新的内核，并保护了发生 panic 的现场，即内核的 kdump。在进入新系统之后，可以使用如下命令获得发生 panic 时的 vmcore:

{% highlight bash %}
cp /proc/vmcore <Dump-file>
{% endhighlight %}

"/proc/vmcore" 包含了 kdump 的内容，可以将 kdump 的内容拷贝到一个安全的地方，以便后期使用 crash 进行问题分析排除。当 kdump 内容拷贝完毕之后，接下来就是使用 crash 排除问题，参考如下命令:

{% highlight bash %}
crash <Dump-file> vmlinux
{% endhighlight %}

如上命令，"Dump-file" 就是从问题机器上保留的 kdump 文件，而 vmlinux 则是带有 debug-info 的内核镜像. 接下来 Crash 调试方法可以参考 Crash 使用章节.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

-------------------------------------

###### <span id="C9">内核转储文件分析</span>

当获得内核核心转储文件之后，可以使用 CRASH 工具进行分析，同样分析方法使用如下命令:

{% highlight bash %}
crash <Dump-file> vmlinux
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000649.png)

当在 ARM/ARM64 中需要设置 kimage_voffset, 即:

{% highlight bash %}
crash <Dump-file> vmlinux kimage_voffset=<voffset>
{% endhighlight %}

需要使用 voffset 为正确的地址才能使用 crash 正常调试内核转储文件。voffset 地址的获得方法通过 gdb 获得:

{% highlight bash %}
(gdb) add-symbol-file vmlinux 0x40081000
(gdb) watch kimage_voffset
(gdb) r/c
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000678.png)

此时将 18446462597927534592 转换为十六进制 0xFFFEFFFFD0000000, 那么使用 crash 工具如下:

{% highlight bash %}
crash <Dump-file> vmlinux kimage_voffset=0xFFFEFFFFD0000000
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

<span id="B81"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000G.jpg)

#### BiscuitOS 方案

BiscuitOS 方案指的是基于 BiscuitOS 构建的内核 kdump 抓取方案。该方案的主要思路与同样方案一致，不同点在于使用 BiscuitOS 快速部署所需的工具和开发环境。在该方案中当内核发生 panic 的时候，可以使用 kexec 快速重启一个新的内核，以此给维护人员创造一个保留问题现场的机会，在进入新系统之后维护人员可以将内核 kdump 内容保存在指定位置，以此由于后期问题的排除。为了实现上面的功能，需要打开内核某些功能，并为 kexec 提供一个可以快速重启的内核，最后就是使用 crash 等工具进行问题排除。由于该实践基于 BiscuitOS linux 5.0 X86_64 架构，没有搭建该环境的开发者可以先搭建环境再实践。那么开发者接下来参考下面的内容进行部署实践:

> - [BiscuitOS 内核转储 Kdump 内核配置](#BX0)
>
> - [BiscuitOS 内核转储 CMDLINE 配置](#B02)
>
> - [BiscuitOS kexec-tools 部署](#B04)
>
> - [BiscuitOS 内核转储 kdump 抓捕过程](#C1)
>
> - [基于 Linux 5.0 X86_64 架构的 BiscuitOS 环境部署教程](https://biscuitos.github.io/blog/Linux-5.0-x86_64-Usermanual/)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

###### <span id="BX0">BiscuitOS 内核转储 Kdump 内核配置</span>

内核为了支持 kdump 功能，需要打开以下宏，以及不同的架构打开的宏不同:

###### CONFIG_KEXEC

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000630.png)

###### CONFIG_SYSFS

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000631.png)

###### CONFIG_DEBUG_INFO

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000632.png)

###### CONFIG_CRASH_DUMP

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000633.png)

###### CONFIG_PROC_VMCORE

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000634.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

#### <span id="B02">BiscuitOS 内核转储 CMDLINE 配置</span>

内核启用相关的内核配置之后，重新编译内核之后需要在内核的 CMDLINE 中添加 crash 占用的内存大小，其语法如下:

{% highlight bash %}
crashkernel=<range1>:<size1>[,<range2>:<size2>,...][@offset]
range=start-[end]
{% endhighlight %}

BiscuitOS 中内核的 CMDLINE 位于项目目录下的 RunBiscuitOS.sh 脚本中，其中 CMDLINE 变量中，可以参考如下进行添加:

{% highlight bash %}
cd BiscuitOS/output/linux-XXX/
vi RunBiscuitOS.sh

CMDLINE="root=/dev/sda rw rootfstype=${FS_TYPE} console=ttyS0 init=/linuxrc loglevel=8 crashkernel=128M nr_cpus=2"
{% endhighlight %}

如上在 CMDLINE 变量中添加了 "crashkernel=128M nr_cpus" 字段，可以让内核为 kdump 预留的内存大小为 128M。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000638.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

#### <span id="B04">BiscuitOS kexec-tools 部署</span>

在调试过程中，经常需要重启内核以还原现场，进而复现某些问题予以追踪解决. 由于每一
次的内核启动，都会伴随着一次的 boot 自检. 但是，对于已经启动过的同一内核，重复的
 boot 自检完全没有必要，且造成了资源浪费. 此外，有时候需要使用一个小内核来启动一
个大内核. 在这两种需求下，kexec 应运而生，kexec 是一款可以让您重新启动到一个新 Linux 内核的快速重新引导功能部件，不再必须通过固件和引导装载程序阶段，从而跳过序>列中最长的部分，大大减少了重启时间. 对企业级系统而言，Kexec 大大减少了重启引起的
系统宕机时间. 对内核和系统软件开发者而言，Kexec 帮助您在开发和测试成果时可以迅速
重新启动系统，而不必每次都要再经历耗时的固件阶段. BiscuitOS 已经支持 kexec-tools 的自动部署，开发者可以参考如下命令:

###### 源码部署

{% highlight bash %}
cd BiscuitOS
make menuconfig

  [*] Package  --->
      [*] kexec-tools  --->

BiscuitOS/output/linux-XXXX/package/kexec-tools-2.0.22
{% endhighlight %}

###### 源码下载解压

{% highlight bash %}
cd BiscuitOS/output/linux-XXXX/package/kexec-tools-2.0.22
make download
make tar
{% endhighlight %}

###### 源码配置编译安装

{% highlight bash %}
cd BiscuitOS/output/linux-XXXX/package/kexec-tools-2.0.22
make configure
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000635.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

###### <span id="C1">BiscuitOS 内核转储 kdump 抓捕过程</span>

在 BiscuitOS 中，当发生内核 kdump 时可以使用 kexec-tools 重新启动到一个新 Linux 内核，维护者可以利用重启的新内核保存 kdump 内容. 为了 kexec 能够快速重启内核，因此需要准备一个 Dump-capture Kernel, Dump-capture Kernel 在不同的架构中表示不同，例如在 i386 或者 x86_64 中，可以是 vmlinux 或者 bzImage/vmlinuxz; 例如在 arm 架构中可以是 zImage, 而在 ARM64 架构中为 vmlinux/Image. BiscuitOS 会根据不同的架构自动准备该内核。因此在 BiscuitOS 中，可以参照如下命令在系统启动完毕之后运行 kexec 工具:

{% highlight bash %}
kexec -p <Dump-capture-kernel> --initrd=<initrd-for-Dump-capture-kernel> \
      --append=<CMDLINE>
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000636.png)

当在系统中成功运行 kexec 中，接着可以手动触发内核 panic，以此查看功能的完成性:

{% highlight bash %}
echo c > /proc/sysrq-trigger
{% endhighlight %}

当使用该命令之后，内核将触发 panic，正常情况下内核将卡主不运行，当此时 kexec 会>迅速重启一个新的内核，并保护了发生 panic 的现场，即内核的 kdump。在进入新系统之后，可以使用如下命令获得发生 panic 时的 vmcore:

{% highlight bash %}
cp /proc/vmcore <Dump-file>
{% endhighlight %}

"/proc/vmcore" 包含了 kdump 的内容，可以将 kdump 的内容拷贝到 BiscuitOS 的一个磁盘上，以便后期使用 crash 进行问题分析排除。

![如果图片不能正常显示，请先在网页上登录 Gitee](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000637.png)

如上图所示，当发生 panic 之后，kexec 工具重启了一个新的内核，并在新内核上保存了 kdump 的内容到 "/mnt/Freeze" 目录。当 kdump 内容拷贝完毕之后，接下来就是将 kdump 文件从 BiscuitOS 中拷贝到 Host 主机中，参考如下命令:

{% highlight bash %}
cd BiscuitOS/output/linux-XXXX/
./RunBiscuitOS.sh mount
cp FreezeDir/kdump ./
./RunBiscuitOS.sh umount
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000639.png)

当从 BiscuitOs 的 Freeze 磁盘上获得了 kdump 的内容之后，接下来使用 crash 排除问题，此时需要使用带有 debug-info 的内核镜像，因此可以使用 vmlinux，参考如下命令:

{% highlight bash %}
cd BiscuitOS/output/linux-XXXX/
crash kdump linux/linux/vmlinux
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000640.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="B82"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Q.jpg)

#### 标准发行版方案 (RedHat/Ubuntu)

相对于通用方案和 BiscuitOS 方案，在标准发行版 RedHat 或者 Ubuntu 中已经集成了完整的开发工具链，因此开发者可以将关注力放在分析内核核心转储本身。由于发行版一般采用 GRUB 引导内核的启动，因此在 CMDLINE 的修改上会有差异，并且系统为 kdump 添加了服务，因此可以对抓捕 kdump 过程进行定制化配置。当系统发生内核转储的时候，系统可以将 kdump 文件保存在配置之后的位置. 那么接下来以 Ubuntu 为例进行讲解:

> - [发行版内核核心转储 kdump 内核配置](#BX2)
>
> - [发行版内核核心转储 kdump CRUB CMDLINE 配置](#B06)
>
> - [Kdump 工具链安装](#B05)
>
> - [发行版内核核心转储 kdump 抓捕过程](#C2)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

###### <span id="BX2">BiscuitOS 内核转储 Kdump 内核配置</span>

内核为了支持 kdump 功能，需要打开以下宏, 在标准发新版中可以按如下方法确认宏是否打开，如果没有打开，需要重新编译发行版的内核:

{% highlight bash %}
cat /boot/config-$(uname -r) | grep <MACRO>
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000641.png)

###### CONFIG_KEXEC

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000630.png)

###### CONFIG_SYSFS

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000631.png)

###### CONFIG_DEBUG_INFO

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000632.png)

###### CONFIG_CRASH_DUMP

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000633.png)

###### CONFIG_PROC_VMCORE

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000634.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------

###### <span id="B06">发行版内核核心转储 kdump CRUB CMDLINE 配置</span>

为了支持 kdump 需要在内核的 CMDLINE 中添加 crashkernel 字段，该字段的语法如下:

{% highlight bash %}
crashkernel=<range1>:<size1>[,<range2>:<size2>,...][@offset]
range=start-[end]
{% endhighlight %}

标准发行版的 CMDLINE 位于 GRUB 中，因此可以参考如下进行添加:

{% highlight bash %}
vi /etc/default/grub

GRUB_TIMEOUT=5
GRUB_DEFAULT=saved
GRUB_DISABLE_SUBMENU=true
GRUB_TERMINAL_OUTPUT="console"
GRUB_CMDLINE_LINUX="crashkernel=128M rd.lvm.lv=centos/root rd.lvm.lv=centos/swap rhgb quiet"
GRUB_DISABLE_RECOVERY="true"
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000642.png)

在 GRUB_CMDLINE_LINUX 变量中修改 crashkernel 的大小，例如系统物理内存 512M，那么保留 256M 给 kdump. 注意预留内存过小会导致生成的 coredump 文件失败 (不知道设置多少时，可以尝试每次增加 128M), 修改后还需重启 grub 配置文件，重启系统才生效:

{% highlight bash %}
grub2-mkconfig -o /boot/grub/grub.cfg
reboot
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000643.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

#### <span id="B05">Kdump 工具链安装</span>

在调试过程中，经常需要重启内核以还原现场，进而复现某些问题予以追踪解决. 由于每一
次的内核启动，都会伴随着一次的 boot 自检. 但是，对于已经启动过的同一内核，重复的
 boot 自检完全没有必要，且造成了资源浪费. 此外，有时候需要使用一个小内核来启动一
个大内核. 在这两种需求下，kexec 应运而生，kexec 是一款可以让您重新启动到一个新 Linux 内核的快速重新引导功能部件，不再必须通过固件和引导装载程序阶段，从而跳过序>列中最长的部分，大大减少了重启时间. 对企业级系统而言，Kexec 大大减少了重启引起的
系统宕机时间. 对内核和系统软件开发者而言，Kexec 帮助您在开发和测试成果时可以迅速
重新启动系统，而不必每次都要再经历耗时的固件阶段. 主流的 RedHat 和 Ubuntu 工具部署可以参考如下命令:

{% highlight bash %}
on RedHat:
  sudo yum install -y kexec-tools
  sudo yum install -y crash

on Ubuntu:
  sudo apt install -y kdump-tools
  sudo apt install -y crash
  sudo apt install -y kexec-tools
  sudo apt install -y makedumpfile
  sudo apt install -y linux-crashdump
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000644.png)

修改 kdump 默认配置 /etc/kdump.conf, CentOS 默认安装 kdump，根据需要修改默认配置
:

{% highlight bash %}
vi /etc/kdump.conf

#指定 coredump 文件存储位置
path /var/crash
#增加-c参数，代表压缩 coredump 文件
core_collector makedumpfile -c -l --message-level 1 -d 31
#生成coredump后，重启系统，
default reboot
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------------------

<span id="B83"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000F.jpg)

#### QEMU 方案

QEMU 提供了内置工具可以在虚拟机发生 panic 是获得内核转储文件 kdump，这样大大方便了问题的调试。开发者可以参考如下步骤进行实践, 由于 BiscuitOS 基于 qemu 运行，因此本节以 BiscuitOS 进行讲解:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000645.png)

首先向 "/proc/sys/kernel/panic" 文件节点写入 0，以防止 coredump 的时候发生 reboot，以此保留问题现场。接着向 "/proc/sysrq-trigger" 节点写入 c，以此模拟内核转储 kdump.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000646.png)

当触发内存转储之后，使 qemu 进入 monitor 模式，通过输入:

{% highlight bash %}
ctrl + a --> c
{% endhighlight %}

先输入 "ctrl a", 然后按下 "c" 按键，此时进入 qemu 的 monitor 模式，接下来在 monitor 模式下输入 "dump-guest-memory" 命令:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000647.png)

在 "dump-guest-memory" 命令中，参数 "-z" 表示将内核转储文件进行压缩，"BiscuitOS-kdump" 参数表示内核转储文件的名字。命令执行成功之后，按下 "crtl a" 后接着按下 "x" 退出 qemu，此时在 Host 主机的当前目录下将看到内核转储文件 BiscuitOS-kdump. 接下来就是利用 crash 工具和 vmlinux 进行调试:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000648.png)

同上使用 crash 进行调试，这里需要注意的是 vmlinux 是待 debug info 的文件，因此在编译内核的时候请确保如下宏已经打开:

{% highlight bash %}
CONFIG_KEXEC
CONFIG_SYSFS
CONFIG_DEBUG_INFO
CONFIG_CRASH_DUMP
CONFIG_PROC_VMCORE
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="E00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000P.jpg)

#### Crash 寄存器约定与函数参数传递

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000649.png)

当使用 Crash 工具查看内核转储文件的堆栈时，Crash 工具可能会输出一堆寄存器信息，具体寄存器与架构有关，例如上图的 X86_64 架构，寄存器包含了 EAX/EBX/EDX/ECX/EDI/ESI/RIP/RSP 寄存器等，这些寄存器表示内核转储时寄存器快照。结合寄存器在不同架构上的使用约定，可以通过这些寄存器信息获得一些利于问题分析的信息，例如可以通过这些寄存器获得某个函数参数传递的信息。由于寄存器的约定与架构有关，那么接下来对不同的架构进行逐一分析:

> [X86_64 架构](#E001)
>
> [i386 架构](#E002)
>
> [ARM64 架构](#E003)
>
> [ARM32 架构](#E004)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------

###### <span id="E001">X86_64 架构</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000650.png)

在 X86_64 架构中，寄存器的约定如上，当调用一个函数的时候，RDI 寄存器用于传递第一个参数，RSI 寄存器用于传递第二个寄存器，依次类推，R9 寄存器传递第六个参数, 函数返回值保存在 RAX 寄存器中。那么如果函数的参数超过六个，那么多余的参数参数如何传递? 在 X86_64 架构中，函数大于 6 个参数的参数通过堆栈进行传输:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000651.png)

当函数的参数超过六个之后，超过的参数从右到左存储在堆栈中，调用者在调用函数之前，将最后一个参数压缩堆栈，其次将倒数第二个压入堆栈，直到将第七个参数压入堆栈为止。参数压入完毕之后向堆栈中压入函数的返回地址，其余的第一个参数到第六个参数都按约定存储在寄存器中。接下来通过一个实例来实践整个过程，BiscuitOS 已经支持该实例实践，其在 BiscuitOS 中的部署如下:

{% highlight bash %}
cd BiscuitOS
make linux-5.0-x86_64_defconfig
make menuconfig

  [*] Package  --->
      [*] CRASH and BUG Example  --->
          [*] Example: Function arguments  --->

BiscuitOS/output/linux-5.0-x86_64/package/BiscuitOS-crash-register-with-func-argument-default
{% endhighlight %}

> [BiscuitOS-crash-register-with-func-argument-default Source Code](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Tools/Crash/BiscuitOS-crash-register-with-func-argument)
>
> [BiscuitOS 独立程序实践教程](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000652.png)

实践案例为一个内核模块，在实践案例中定义了一个函数 BiscuitOS_func_arguments(), 其包含了 20 个参数，并在调用该函数时会触发内核转储，因此可以通过汇编和 CRASH 工具查看函数参数传递过程，首先使用如下命令获得汇编文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-x86_64/package/BiscuitOS-crash-register-with-func-argument-default
make
vi BiscuitOS-crash-register-with-func-argument-default/main.s
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000653.png)

* 114 行第一个参数通过 RDI 寄存器传递
* 112 行第二个参数通过 RSI 寄存器传递
* 110 行第三个参数通过 RDX 寄存器传递
* 108 行第四个参数通过 RCX 寄存器传递
* 106 行第五个参数通过 R8 寄存器传递
* 103 行第六个参数通过 R9 寄存器传递

{% highlight bash %}
movq	112(%rsp), %rax
movl	(%rax), %eax
pushq	%rax
{% endhighlight %}

对于第六个之后的参数，函数首先通过上面的方法获得。程序首先通过 "112(%rsp)" 的方式在堆栈中找到最后一个参数的位置，并将参数的地址存储到 RAX 寄存器，接着将 RAX 寄存器对应地址的值进行读取，这样就获得指定参数。读取完毕之后，程序调用 "pushq" 的方式将 RSP 寄存器的值指向下一帧 (指向更低的地址)，然后程序重复上面的代码读取下一个参数，以此类推获得第六个之后的参数. 接着在 BiscuitOS 上运行并获得内核转储文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-x86_64/package/BiscuitOS-crash-register-with-func-argument-default
make
make install
make pack
make run
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000654.png)

当在 BiscuitOS 中加载模块 BiscuitOS-crash-register-with-func-argument-
default.ko，由于代码中对空指针的引用，此时内核触发 panic，此时内核打印出内核转储时寄存器的信息，从运行可知 data 数组的地址为 0xffffffffc0087000, 那么此时 EDI 寄存器中存储了第一个参数，其值也为 0xffffffffc0087000; 同理 ESI 寄存器中存储了第二个参数，其值为 ffffffffc0087004, 正好是函数第二个参数的值，依次类推，RDX/RCX/R8/R9 寄存器均存储函数的参数。实践结果符合预期.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------

###### <span id="E002">i386 架构</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000655.png)

在 i386 架构中，寄存器的约定如上，寄存器的使用与 "\_\_attribute\_\_((regparm(n)))" 有关，当 n 为 0 时表示使用零个寄存器传递函数的参数; 当 n 为 1 时表示使用一个寄存器传递函数参数; 以此类推，n 的范围是 0-3, 因此最多可以使用 3 个寄存器传递参数, 默认情况下，当函数参数数量超过 n 的最大值时，n 默认为 3，那么这个时候系统使用 3 个寄存器传递函数参数。但函数使用寄存器传递参数时，默认约定是: 当调用一个函数的时候，EAX 寄存器用于传递第一个参数，EDX 寄存器用于传递第二个寄存器，ECX 寄存器传递第三个寄存器。函数返回值保存在 EAX 寄存器中. 那么如果函数的参数超过 "\_\_attribute\_\_((regparm(n)))" 所规定的 n 个寄存器时，那么多余的参数参数如何传递? 在 i386 架构中，函数大于 n 个参数的参数通过堆栈进行传输:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000656.png)

当函数的参数超过三个之后，超过的参数从右到左存储在堆栈中，调用者在调用函数之前，将最后一个参数压缩堆栈，其次将倒数第二个压入堆栈，直到将第四个参数压入堆栈为止。参数压入完毕之后向堆栈中压入函数的返回地址，其余的第一个参数到第三个参数都按约定存储在寄存器中。接下来通过一个实例来实践整个过程，BiscuitOS 已经支持该实例实践，其在 BiscuitOS 中的部署如下:

{% highlight bash %}
cd BiscuitOS
make linux-5.0-i386_defconfig
make menuconfig

  [*] Package  --->
      [*] CRASH and BUG Example  --->
          [*] Example: Function arguments  --->

BiscuitOS/output/linux-5.0-i386/package/BiscuitOS-crash-register-with-func-argument-default
{% endhighlight %}

> [BiscuitOS-crash-register-with-func-argument-default Source Code](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Tools/Crash/BiscuitOS-crash-register-with-func-argument)
>
> [BiscuitOS 独立程序实践教程](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000652.png)

实践案例为一个内核模块，在实践案例中定义了一个函数 BiscuitOS_func_arguments(), 其包含了 20 个参数，并在调用该函数时会触发内核转储，因此可以通过汇编和内核转储信息查看函数参数传递过程，首先使用如下命令获得汇编文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-i386/package/BiscuitOS-crash-register-with-func-argument-default
make
vi BiscuitOS-crash-register-with-func-argument-default/main.s
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000657.png)

* 58 行第一个参数通过 EAX 寄存器传递
* 57 行第二个参数通过 EDX 寄存器传递
* 56 行第三个参数通过 ECX 寄存器传递

{% highlight bash %}
movl    offset(%ebp), %ebx
{% endhighlight %}

对于第四个之后的参数，汇编直接通过 "offset(stack)" 的方式从堆栈中获得参数的内容，并将其 movl 存储到指定寄存器中。开发者也可以参数通过在函数中添加 "\_\_attribute\_\_((regparm(n)))" 来查看寄存器数量的变化情况:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000661.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000662.png)

当 "\_\_attribute\_\_((regparm(n)))" n 为 0 时，此时函数不使用寄存器传递参数，可以看出所有参数都通过堆栈传递。上图 176 行从堆栈 "8(%ebp)" 中找到了第一个参数.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000663.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000664.png)

当 "\_\_attribute\_\_((regparm(n)))" n 为 1 时，此时函数只使用 EAX 寄存器传递参数，可以看出其余参数都通过堆栈传递。上图 174 行从 EAX 寄存器中获得第一个参数，其余参数都从堆栈 "offset(%ebp)" 中找获得.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000665.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000666.png)

当 "\_\_attribute\_\_((regparm(n)))" n 为 2 时，此时函数使用 EAX 寄存器传递第一个参数，使用 EDX 寄存器传递第二个参数，其余参数都通过堆栈传递。上图 172 行通过 EAX 传递第一个参数，172 行通过 EDX 寄存器传递第二个参数， 其余参数从堆栈 "offset(%ebp)" 中获得.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000658.png)
![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000667.png)

当 "\_\_attribute\_\_((regparm(n)))" n 为 3 时，此时函数使用 EAX 寄存器传递第一个参数，使用 EDX 寄存器传递第二个参数，使用 ECX 寄存器传递第三个参数，其余参数通过堆栈传递。上图 153 行通过 EAX 寄存器获得第一个参数，152 行通过 EDX 寄存器获得第二个参数，151 行通过 ECX 寄存器获得第三个寄存器，其余通过 "offset(%ebp)" 从堆栈中获得.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000660.png)

在 BiscuitOS 加载实践模块之后，触发内核核心转储，此时数组的地址是 0xe0a5e000, 那么可以看到 EAX 寄存器指向第一个参数，正好是 0xe0a5e000; EDX 寄存器指向第二个参数，其值为 0xe0a5e004, 这样是数组的第二个成员地址; 同理 ECX 寄存器指向第三个参数，其值为 0xe0a5e008, 正好是数组的第三个成员地址.

另外，X86 总共有三种调用约定，Cdecl、stdcall 和 fastcall 调用规范，三者的区别:


* Cdecl 调用规范: 参数从右往左一次入栈，调用者实现栈平衡，返回值存放在 EAX
* stdcall调用规范: 参数从右往左一次入栈，被调用者实现栈平衡，返回值存放在 EAX
* fastcall 调用规范: 参数 1、参数 2 分别保存在 ECX、EDX, 剩下的参数从右往左一次入栈，被调用者实现栈平衡，返回值存放在 EAX

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------

###### <span id="E003">ARM64 架构</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000668.png)

在 ARM64 架构中，使用 X0-X7 寄存器传递参数，第一个参数通过 X0 寄存器传递，第二个参数通过 X1 寄存器传递，以此类推. 返回值存储在 X0 寄存器中.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000669.png)

当函数参数的数量超过 8 个之后，那么多余的参数从右到左依次入栈，被调用者平衡堆栈.接下来通过一个实例来实践整个过程，BiscuitOS 已经支持该实例实践，其在 BiscuitOS 中的部署如下:

{% highlight bash %}
cd BiscuitOS
make linux-5.0-aarch_defconfig
make menuconfig

  [*] Package  --->
      [*] CRASH and BUG Example  --->
          [*] Example: Function arguments  --->

BiscuitOS/output/linux-5.0-aarch/package/BiscuitOS-crash-register-with-func-argument-default
{% endhighlight %}

> [BiscuitOS-crash-register-with-func-argument-default Source Code](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Tools/Crash/BiscuitOS-crash-register-with-func-argument)
>
> [BiscuitOS 独立程序实践教程](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000652.png)

实践案例为一个内核模块，在实践案例中定义了一个函数 BiscuitOS_func_arguments(), 其包含了 20 个参数，并在调用该函数时会触发内核转储，因此可以通过汇编和内核转储信息查看函数参数传递过程，首先使用如下命令获得汇编文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-aarch/package/BiscuitOS-crash-register-with-func-argument-default
make
vi BiscuitOS-crash-register-with-func-argument-default/main.s
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000671.png)

* 38 行第一个参数通过 X0 寄存器传递
* 37 行第二个参数通过 X1 寄存器传递
* 36 行第三个参数通过 X2 寄存器传递
* 35 行第四个参数通过 X3 寄存器传递
* 34 行第五个参数通过 X4 寄存器传递
* 33 行第六个参数通过 X5 寄存器传递
* 29 行第七个参数通过 X6 寄存器传递
* 57 行第八个参数通过 X7 寄存器传递

{% highlight bash %}
ldp reg, reg, [x29, offset]
{% endhighlight %}

汇编程序在 12 行到 18 行通过将 x29 寄存器指向参数在堆栈中的位置，然后通过寄存器加偏移的方式将参数的内容读出. 汇编源码第 19 行从堆栈中读出第 15 和第 16 个参数; 第 20 行从堆栈中读出第 17 和第 18 个参数; 第 21 行从堆栈中读出第 19 和第 20 个参数; 第 22 行从堆栈中读出第 9 和第 10 个参数; 第 23 行从堆栈中读出第 11 和第 12 个参数; 第 24 行从堆栈中读出第 13 和第 14 个参数. 接着在 BiscuitOS 上运行并获得内核转储文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-aarch/package/BiscuitOS-crash-register-with-func-argument-default
make
make install
make pack
make run
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000672.png)

当在 BiscuitOS 中加载模块 BiscuitOS-crash-register-with-func-argument-default.ko，由于代码中对空指针的引用，此时内核触发 panic，此时内核打印出内核转储时寄存器的信息，从运行可知 data 数组的地址为 0xffff000008b42000, 那么寄存器与数组的关系:

* X0: 0xffff000008b42000 DATA[0]: 0xffff000008b42000
* X1: 0xffff000008b42004 DATA[1]: 0xffff000008b42004
* X2: 0xffff000008b42008 DATA[1]: 0xffff000008b42008
* X3: 0xffff000008b4200c DATA[1]: 0xffff000008b4200c
* X4: 0xffff000008b42010 DATA[1]: 0xffff000008b42010
* X5: 0xffff000008b42014 DATA[1]: 0xffff000008b42014
* X6: 0xffff000008b42018 DATA[1]: 0xffff000008b42018
* X7: 0xffff000008b4201c DATA[1]: 0xffff000008b4201c

寄存器的值与分析一致，实践符合预期.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

--------------------------------

###### <span id="E004">ARM 架构</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000674.png)

在 ARM32 架构中，使用 R0-R3 寄存器传递参数，第一个参数通过 R0 寄存器传递，第二个参数通过 R1 寄存器传递，以此类推. 返回值存储在 R0 寄存器中.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000675.png)

当函数参数的数量超过 4 个之后，那么多余的参数从右到左依次入栈，被调用者平衡堆栈.接下来通过一个实例来实践整个过程，BiscuitOS 已经支持该实例实践，其在 BiscuitOS 中的部署如下:

{% highlight bash %}
cd BiscuitOS
make linux-5.0-arm32_defconfig
make menuconfig

  [*] Package  --->
      [*] CRASH and BUG Example  --->
          [*] Example: Function arguments  --->

BiscuitOS/output/linux-5.0-arm32/package/BiscuitOS-crash-register-with-func-argument-default
{% endhighlight %}

> [BiscuitOS-crash-register-with-func-argument-default Source Code](https://gitee.com/BiscuitOS_team/HardStack/tree/Gitee/Tools/Crash/BiscuitOS-crash-register-with-func-argument)
>
> [BiscuitOS 独立程序实践教程](https://biscuitos.github.io/blog/Human-Knowledge-Common/#C)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000652.png)

实践案例为一个内核模块，在实践案例中定义了一个函数 BiscuitOS_func_arguments(), 其包含了 20 个参数，并在调用该函数时会触发内核转储，因此可以通过汇编和内核转储信息查看函数参数传递过程，首先使用如下命令获得汇编文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-arm32/package/BiscuitOS-crash-register-with-func-argument-default
make
vi BiscuitOS-crash-register-with-func-argument-default/main.s
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000673.png)

* 30 行第一个参数通过 R0 寄存器传递
* 29 行第二个参数通过 R1 寄存器传递
* 28 行第三个参数通过 R3 寄存器传递
* 65 行第四个参数通过 R4 寄存器传递

{% highlight bash %}
lsr	reg, [sp, #offset]
{% endhighlight %}

汇编程序通过在堆栈加偏移的方式将参数的内容读出. 汇编源码第 36 行从堆栈中读出第 20 个参数; 第 58 行从堆栈中读出第 13 个参数， 以此类推. 接着在 BiscuitOS 上运行并获得内核转储文件:

{% highlight bash %}
cd BiscuitOS/output/linux-5.0-arm32/package/BiscuitOS-crash-register-with-func-argument-default
make
make install
make pack
make run
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000676.png)

当在 BiscuitOS 中加载模块 BiscuitOS-crash-register-with-func-argument-default.ko，由于代码中对空指针的引用，此时内核触发 panic，此时内核打印出内核转储时寄存器的信息，从运行可知 data 数组的地址为 0xffff000008b42000, 那么寄存器与数组的关系:

* R0: 0x7f002000 DATA[0]: 0x7f002000
* R1: 0x7f002004 DATA[1]: 0x7f002004
* R2: 0x7f002008 DATA[2]: 0x7f002008
* R3: 0x7f00200c DATA[3]: 0x7f00200c

从上图可以看出堆栈从 "0x9dae3d10" 到 "0x9dae4000" 的内容，那么第五个参数的在堆栈中的地址是 "0x9dae3d88", 具体对应关系如下, 实践结果符合预期:

* Stack 0x9dae3d88: 0x7f002010 DATA[04]: 0x7f002010
* Stack 0x9dae3d8c: 0x7f002014 DATA[05]: 0x7f002014
* Stack 0x9dae3d90: 0x7f002018 DATA[06]: 0x7f002018
* Stack 0x9dae3d94: 0x7f00201c DATA[07]: 0x7f00201c
* Stack 0x9dae3d98: 0x7f002020 DATA[08]: 0x7f002020
* Stack 0x9dae3d9c: 0x7f002024 DATA[09]: 0x7f002024
* Stack 0x9dae3da0: 0x7f002028 DATA[10]: 0x7f002028
* Stack 0x9dae3da4: 0x7f00202c DATA[11]: 0x7f00202c
* Stack 0x9dae3da8: 0x7f002030 DATA[12]: 0x7f002030
* Stack 0x9dae3dac: 0x7f002034 DATA[13]: 0x7f002034
* Stack 0x9dae3db0: 0x7f002038 DATA[14]: 0x7f002038
* Stack 0x9dae3db4: 0x7f00203c DATA[15]: 0x7f00203c
* Stack 0x9dae3db8: 0x7f002040 DATA[16]: 0x7f002040
* Stack 0x9dae3dbc: 0x7f002044 DATA[17]: 0x7f002044
* Stack 0x9dae3dc0: 0x7f002048 DATA[18]: 0x7f002048
* Stack 0x9dae3dc4: 0x7f00204c DATA[19]: 0x7f00204c

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="E01"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000M.jpg)

#### Crash 报告信息分析

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000679.png)

当使用 CRASH 工具分析 VMCORE 的时候，CRASH 工具就会输出一些基本信息，例如所分析内核版本的信息等，那么这些基本信息具体含义如何? 以上图为例进行逐一分析:

* KERNEL: 内核崩溃时运行的 Kernel ELF 文件.
* DUMPFILE: 内核转储文件.
* CPUS: 机器 CPU 的数量.
* DATE: 系统崩溃的时间.
* UPTIME: 系统启动到系统奔溃的时间.
* LOAD AVERAGE: 
* TASKS: 系统崩溃时内存中的任务数.
* NODENAME: 崩溃系统的主机名.
* RELEASE: 崩溃内核的版本号.
* VERSION: 崩溃内核的版本号.
* MACHINE: CPU 架构和主频信息.
* MEMORY: 崩溃主机的物理内存.
* PANIC: 崩溃类型.
* PID: 导致内核崩溃的进程号.
* COMMAND: 导致内核崩溃的命令.
* TASK:
* CPU:
* STATE:

CRASH 输出的基本信息处理以上描述之外还包括: CRASH 版本信息以及 GDB 版本信息.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

----------------------------------

<span id="E02"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000I.jpg)

#### Crash 堆栈使用以及问题定位分析

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000649.png)

当使用 CRASH 分析内核转储文件时，堆栈的信息对问题排除起到了关键作用，CRASH 也提供了多个堆栈分析的命令，如下:

{% highlight bash %}
bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-I ip] [-S sp] [pid | task]
{% endhighlight %}

本节以手动触发 Panic 为例进行实践讲解。在 BiscuitOS 上通过输入 "echo c > /proc/sysrq-trigger" 来触发内核崩溃，并对转储文件为例进行分析:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000680.png)

> [CRASH 堆栈基本信息分析](#E0203)
>
> [crash> bt 打印引起内核奔溃 TASK 的堆栈](#E0202)
>
> [crash> bt -a 打印内核奔溃时所有 TASK 的堆栈](#E0200)
>
> [crash> bt -g](#E0201)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------

###### <span id="E0203">CRASH 堆栈基本信息分析</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000649.png)

当通过 CRASH 工具的 bt 命令分析内核转储文件的堆栈时，CRASH 将会输出奔溃时进程相关的信息、函数调用栈、以及寄存器快照，其中进程相关的信息描述如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000684.png)

* PID: 描述发生内核奔溃 CPU 上正在运行进程的 PID 信息.
* TASK: 描述发生内核奔溃 CPU 上运行进程的描述符的内存地址.
* CPU: 描述发生内核奔溃的 CPU ID.
* COMKMAND: 描述发生内核奔溃 CPU 上正在运行的程序.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000682.png)

接下来是堆栈内容区域，最左边的 "#数字" 部分表示发生内核奔溃时函数调用栈，数字越小表示最新的调用，可以通过这个信息找到内核奔溃前最后调用函数的信息. 中间的地址部分描述被调用函数的地址在堆栈中的地址，中间函数表示调用栈中函数的名字，紧随名字之后的地址是函数在调用下一个函数的地址，例如 "#5" 处调用 \_\_vfs_write() 函数，该函数的地址在堆栈的地址是 0xffffaa4e8020fe48, 那么该函数此时在 0xffffffffa5431bd1 处调用了下一个函数 proc_reg_write.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000683.png)

最后一部分是内核发生崩溃时某个时刻的寄存器信息，例如上图当发生内核崩溃时内核调用了 entry_SYSCALL_64_after_hwframe() 函数时的寄存器快照。该快照根据不同架构打印不同寄存器信息, 在分析问题时结合特定架构寄存器约定信息，对问题的定位起到了不可忽视的作用. 不同架构的寄存器约定可以参考:

> [Crash 寄存器约定与函数参数传递](#E00)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------

###### <span id="E0200">bt -a 打印内核奔溃时所有 TASK 的堆栈</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/TH000681.png)

"bt -a" 是以 TASK 为单位显示每个 TASK 的堆栈信息.

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND000100.png)

------------------------------

###### <span id="E0201">bt -a 打印内核奔溃时所有 TASK 的堆栈</span>


-----------------------------------------------

#### <span id="Z0">附录</span>

> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Blog 2.0](https://biscuitos.github.io/blog/BiscuitOS_Catalogue/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)
>

#### 捐赠一下吧 🙂

![MMU](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/HAB000036.jpg)
