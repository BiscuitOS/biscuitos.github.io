---
layout: post
title:  "PCF8574AT"
date:   2019-10-13 13:17:30 +0800
categories: [HW]
excerpt: I2C AT24CXX.
tags:
  - LDD
---

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L0.PNG)

> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

## 目录

> - [PCF8574AT 简介](#A00)
>
> - [实践准备](#A10)
>
>   - [硬件准备](#P00)
>
>   - [软件准备](#P01)
>
> - [PCF8574AT 驱动](#A011)
>
>   - [PCF8574AT 驱动分析](#B00)
>
>   - [PCF8574AT BiscuitOS-RaspberryPi 实践部署](#B01)
>
>   - [PCF8574AT 工程实践部署](#B02)
>
> - [PCF8574AT 工具](#A012)
>
> - [PCF8574AT 应用程序](#A013)
>
>   - [PCF8574AT 应用程序分析](#B03)
>
>   - [PCF8574AT BiscuitOS-RaspberryPi 中使用](#B04)
>
>   - [PCF8574AT 工程实践部署](#B05)
>
> - [PCF8574AT 工程应用](#A016)
>
>   - [交通灯](#G000)
>
> - [PCF8574AT 问题合集](#B10)
>
>   - [I2C 总线无法找到 PCF8574AT](#C00)
>
>   - [PCF8574AT 多次写失败](#CD00)
>
> - [PCF8574AT 进阶研究](#F000)
>
> - [附录/捐赠](#A017)

------------------------------------------

<span id="A00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000A.jpg)

## PCF8574AT 简介

PCF8574 是一个 8bit 的 GPIO 拓展芯片，提供了标准的 I2C 接口。PCF8574 具有
低电流消耗以及具有高电流驱动能力的锁存输出，可用于驱动 LED 等。PCF8574
还拥有一条中断线 (INT) 用于连接到主控的中断逻辑上。PCF8574AT 具有 8 个可
用的 GPIO，每当 GPIO 的状态改变时，PCF8574 的 INT 引脚将会产生一个中断
信号，从而知道 GPIO 的状态，而不必通过轮寻的方式检查 GPIO 的状态。主控
可以通过 I2C 总线向 8 个 GPIO 写值，也可以读取 8 个 GPIO 的值。PCF8574
一般用于 GPIO 紧缺的情况，可以在 I2C 总线上挂载多个 PCF8574 来增加 GPIO
的数量。

> [PCF8574AT Datasheet](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/PCF8574AT.pdf)

市面上也提供了很过针对 PCF8574AT 的模块设计，例如下图：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000116.JPEG)

------------------------------------------

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000H.jpg)

## <span id="A10">实践准备</span>

BiscuitOS 已经支持 PCF8574AT 的硬件实践，但在实践前需要作相应的准备，
必须要的准备有：

> - [硬件准备](#P00)
>
> - [软件准备](#P01)

------------------------------------------

<span id="P00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Z.jpg)

## 硬件准备

在开发 PCF8574AT 驱动前，开发者应该准备下列硬件.

> - [硬件平台](#P000)
>
> - [PCF8574AT](#P001)
>
> - [逻辑分析仪](#P002)
>
> - [示波器](#P003)
>
> - [硬件连接](#P004)

---------------------------------------------------

##### <span id="P000">硬件平台</span>

开发者需要准备一块 RaspberryPi 4B 开发板，并配有 SD 卡，SD 读卡器，
TTL 转 USB 串口一个。

> - [RaspberryPi 官网](https://www.raspberrypi.org/)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000016.png)

------------------------------------------

##### <span id="P001">PCF8574AT</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000116.JPEG)

开发者可以从网上购买 PCF8574AT 模块。

------------------------------------------

##### <span id="P002">逻辑分析仪</span>

逻辑分析仪能够帮助开发者快速分析数据，测试 PCF8574AT 功能，稳定性，
大量数据采样等。逻辑分析仪不是必须的，这里推荐使用 DreamSourceLab
开发的 DSLogic:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000012.jpg)

DSLogic 逻辑分析仪数据工具：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000062.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000063.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000066.png)

> - [DreamSourceLab: DSLogic 官网](https://dreamsourcelab.cn/product/dslogic-plus/)

----------------------------------------

##### <span id="P003">示波器</span>

示波器能够帮助开发者对 I2C 总线进行最透彻的分析，示波器测量
的数据具有可靠性高，精度高的特定，是分析 I2C 问题不可或缺的
工具。示波器建议准备，这里推荐使用 DreamSourceLab 开发的 DsCope:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000013.jpg)

DSCope 示波器采用样图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000006.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000057.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000069.png)

> - [DreamSourceLab: DSLogic 官网](https://dreamsourcelab.cn/product/dscope-u2p20/)

------------------------------------------

##### <span id="P004">硬件连接</span>

在准备好所有的硬件之后，接下来将 PCF8574AT 与 RaspberryPi 4B 连接，
连接如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000117.png)

红线为 VCC (3.3V) 接 PCF8574AT 的 VCC 引脚; 黑线为 GND 接 PCF8574AT
的 GND 引脚; 黄线为 SDA 接 PCF8574AT 的 SDA 引脚; 绿线为 SCL 接
PCF8574AT 的 SCL 引脚, 白线接到 PCF8574AT 的 INT 引脚上。
RaspberryPi 4B 的引脚定义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000008.png)

连接过程中要注意杜邦线虚连，连接完毕之后请使用万用表确保每条线
都已经连接上。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000121.png)

------------------------------------------

<span id="P01"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000K.jpg)

## 软件准备

在进行 PCF8574AT 软件开发前，开发这应该准备并部署所需的
软件工具及环境。如下表列出的内容:

> - [RaspberryPi 4B 开发环境部署](#P010)
>
> - [内核启用 I2C 功能](#P011)
>
> - [RaspberryPi 4B 启用 I2C 功能](#P012)
>
> - [开发相关文档](#P013)

----------------------------------------

##### <span id="P010">RaspberryPi 4B 开发环境部署</span>

在驱动开发前，开发者需要准备一个能在 RaspberryPi 4B 上运行的
BiscuitOS，具体制作方法可以参考下列文档:

> - [BiscuitOS RaspberryPi 4B 环境部署](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/)

---------------------------------------

##### <span id="P011">内核启用 I2C 功能</span>

为了在 RaspberryPi 上使用 PCF8574AT，开发者应该基于 BiscuitOS RaspberryPi
的开发环境对内核进行配置，开发者可以参考如下命令：

{% highlight bash %}
cd BiscuitOS/output/RaspberryPi_4B/linux/linux
make menuconfig ARCH=arm
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000033.png)

选择并进入 "Device Driver"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000034.png)

选择并进入 "I2C support --->"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000035.png)

以模块的方式选择 "I2C device interface"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000036.png)

选择并进入 "I2C Hardware Bus support --->"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000037.png)

以模块的形式选择 "Broadcom BCM2835 I2C controller", 最后保存并退出。
接着是编译内核和模块，并安装模块和内核到新的 SD 卡上，可以
参数如下文档：

> - [BiscuitOS 树莓派上编译模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A02013)
>
> - [BiscuitOS 树莓派上编译内核](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A013)
>
> - [BiscuitOS 树莓派上安装内核模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A0214)

准备好以上步骤之后，在系统启动之后，使用串口登录到 RaspberryPi，
使用如下命令安装 I2C 总线模块，如下：

{% highlight bash %}
cd /lib/modules/5.0.21/kernel/driver/i2c/bus
insmod busses/i2c-bcm2835.ko
insmod i2c-dev.ko
{% endhighlight %}

-------------------------------------

##### <span id="P012">RaspberryPi 4B 启用 I2C 功能</span>

制作完 BiscuitOS 镜像之后，将 BiscuitOS 镜像烧录到 SD 卡，
烧录完毕之后，重启插拔 SD 读卡器，此时可以获得 SD 卡出现
两个分区，其中一个为 BOOT 分区，如下图：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000049.png)

此时修改 BOOT 分区了的 "config.txt" 文件，RaspberryPi 默认是
关闭 I2C 功能的，此时将下面关于 I2C 的配置打开，如下：

{% highlight bash %}
# Uncomment some or all of these to enable the optional hardware interfaces
dtparam=i2c_arm=on
#dtparam=i2s=on
#dtparam=spi=on
{% endhighlight %}

确保 "dtparam=i2c_arm=on" 没有被注释掉。修改完毕之后，保存退出，最后
移除 SD 卡，将其重新插入到 RaspberryPi 4B 的 SD 卡槽里。

----------------------------------------

##### <span id="P013">开发相关文档</span>

> - [PCF8574AT Datasheet](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/PCF8574AT.pdf)
>
> - [BCM2835 ARM Peripherals](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/RPI/BCM2835.pdf)
>
> - [I2C Bus Specifications](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/I2C_bus_specifications_V2_0.pdf)
>
> - [PCF8574AT Driver and application on Github](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574)

------------------------------------------

<span id="A011"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000T.jpg)

## PCF8574AT 驱动

BiscuitOS 为 PCF8574AT 提供了完整的内核驱动支持，开发者可以参考本节
内容，对 PCF8574AT 进行实践部署。

> - [PCF8574AT 驱动分析](#B00)
>
>   - [PCF8574AT 设备注册](#M00)
>
>   - [PCF8574AT I2C 接口](#M191)
>
>     - [PCF8574AT 随机地址读操作](#M001)
>
>     - [PCF8574AT 连续读操作](#M002)
>
>     - [PCF8574AT 当前地址读操作](#M003)
>
>     - [PCF8574AT 按字节写操作](#M004)
>
>     - [PCF8574AT 按页写操作](#M005)
>
>   - [PCF8574AT 使用](#M192)
>
> - [PCF8574AT BiscuitOS-RaspberryPi 实践部署](#B01)
>
> - [PCF8574AT 工程实践部署](#B02)

------------------------------------------

<span id="B00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000W.jpg)

## PCF8574AT 驱动分析

BiscuitOS 已经支持最新的 PCF8574AT 芯片，开发者可以使用 BiscuitOS 提供
的驱动对 PCF8574AT 进行使用，驱动源码 GithuB 地址如下：

> - [PCF8574AT I/O Expander Device Driver for BiscuitOS](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574/Base/kernel)
>
> - [PCF8574AT Datasheet](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/PCF8574AT.pdf)

BiscuitOS 提供的完整驱动如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000118.png)

驱动分作三个部分，第一个部分是 PCF8574AT 设备注册到对应总线上；第二部分是 
PCF8574AT 提供 I/O Expander 的读写接口；第三部分是驱动对 I/O Expander 的使用。
接下来的内容将详细分析每一部分代码的构成。

> - [PCF8574AT 设备注册](#M00)
>
> - [PCF8574AT I2C 接口](#M1)
>
> - [PCF8574AT 使用](#M2)

-----------------------------------------------

#### <span id="M00">PCF8574AT 设备注册</span>

新版本内核中，I2C 子系统提供了一套简单的接口就可以将一个 I2C 设备
注册到 I2C 子系统。本例程通过向 DTS 中添加 PCF8574AT，并将 PCF8574AT
注册到 I2C 子系统。首先如下图：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000119.png)

函数首先定义一个 struct i2c_driver 结构体，然后填充该结构体。结构体中提供了
driver 成员，在 PCF8574AT 中需要提供 name, owner, 以及 of_match_table 三个
成员，其中 of_match_table 是一个 struct of_device_id 结构，该结构用于与 DTS
中的节点 compatible 属性进行对比，如果相同，即从 DTS 中找到驱动对应的节点，
例如在本例程中，compatible 属性的属性值是 "BiscuitOS,pcf8574"; name 成员必须
与 struct i2c_device_id 结构的 name 成员相同，即总线上的驱动和设备通过名字进行
匹配，在上面的代码中即 pcf8574_id 结果的 name 设置的与 pcf8574_driver 结构的
driver 成员的 name 一致；至于 owner 成员，由于驱动以模块的形式添加到内核，那么
owner 设置为 THIS_MODULE 就行。最后提供 I2C 设备需要的 probe 和 remove 接口。

以上就是简单的驱动端程序设置，设置完毕之后调用 module_i2c_driver() 函数
将 pcf8574_driver 对应的驱动注册到 I2C 子系统上。提供驱动代码还不能让驱动
正常的工作，还需 DTS 中添加 pcf8574 对应的设备节点。开发者可以参考 BiscuitOS
提供的 RaspberryPi 4B 项目的方法进行添加。在 RaspberryPi 4B 中，DTS 位于
内核源码 arch/arm/boot/dts/bcm2711-rpi-4-b.dts, 添加如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000120.png)

在上面的 DTS 文件中，节点名字为 pcf8574，与驱动中的 struct i2c_device_id
name 成员相同。特别值得注意的是节点 reg 属性值必须与节点名字 @ 符号后面的数字
相同，这符合 DTS 语法。reg 属性即 PCF8574AT I2C 的从设备地址。节点的 compatible
属性值必须与驱动的 struct of_device_id 一致。通过上面的代码，系统启动后可以
向系统注册一个简单的 PCF8574AT 模块。 DB-gpio 属性指向中断所在的 GPIO.

-----------------------------------------------

#### <span id="M191">PCF8574AT I2C 接口</span>

通过 PCF8574AT 的数据手册可以知道，PCF8574AT 提供只提供了一种方式的
读和一种方式的写操作，与大多数的 I2C 从设备不同，PCF8574 从设备不能通过
通用的 i2c 工具或函数进行读写，需要对 I2C 的读写过程进行封装。
接下里分别介绍每种操作如何编写代码。

> - [PCF8574AT 读操作](#M001)
>
> - [PCF8574AT 写操作](#M004)

---------------------------------------

###### <span id="M001">PCF8574AT 读操作</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000122.png)

上图定义了 PCF8574AT 的 I2C 总线读操作时序，从上图的定义可以看出，
在主控产生一个 START 信号之后，只需发送向 I2C 总线上发送 PCF8574AT
的从设备地址，并且 R/W bit 设置为 1 即可，此时如果 PCF8574AT 收到
主控发来的请求之后，会通过拉低 SDA 总线产生一个 ACK 应答信号，此时
主控收到应答信号之后，就等待 PCF8574AT 发送两个 Byte 的数据。PCF8574AT
产生第一个 ACK 应答之后，会向 SDA 总线上发送一个 BYTE 的数据，该数据
就是当前 8-bit I/O 的状态，接着采用同样的方式，拉低 ACK 再发送一次
8-bit I/O 的状态。发送完毕两 Byte 的数据之后，主控产生一个 STOP 信息
结束本次读操作。值得注意的是，PCF8574AT 在发送完第一个 BYTE 数据之后，
会在 INT 引脚上产生一个时长为 Tir 的中断。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000027.png)

上图即是根据信号协议编写的 Read 操作函数。在内核中，I2C 子系统定义了
struct i2c_msg 结构为一个 I2C 帧，其定义如下：

{% highlight c %}
struct i2c_msg {
        __u16 addr;     /* slave address                        */
        __u16 flags;
#define I2C_M_RD                0x0001  /* read data, from slave to master */
                                        /* I2C_M_RD is guaranteed to be 0x0001! */
#define I2C_M_TEN               0x0010  /* this is a ten bit chip address */
#define I2C_M_DMA_SAFE          0x0200  /* the buffer of this message is DMA safe */
                                        /* makes only sense in kernelspace */
                                        /* userspace buffers are copied anyway */
#define I2C_M_RECV_LEN          0x0400  /* length will be first received byte */
#define I2C_M_NO_RD_ACK         0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK        0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_REV_DIR_ADDR      0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART           0x4000  /* if I2C_FUNC_NOSTART */
#define I2C_M_STOP              0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */
        __u16 len;              /* msg length                           */
        __u8 *buf;              /* pointer to msg data                  */
};
{% endhighlight %}

根据 PCF8574AT 读时序，主控只需发送一个 i2c_msg 即可，因此定义了
一个 i2c_msg 结构，由于读时序的时候，R/W bit 置位，因此给 i2c_msg
结构的 flags 添加 I2C_M_RD 标志，以此表示该 i2c_msg 用于读操作。
接着根据主控发送 i2c_msg 之后，PCF8574AT 会返回两个 byte 的字节，
因此将 i2c_msg 的 len 设置为 2， 并且 buf 只想一个可以存储 2 个字节
的内存地址。

以上准备好 i2c_msg 之后，继续调用 i2c_transfer() 函数，将 i2c_msg
传递给 I2C 核心层，最终到达 I2C 控制器的收发器上发送。接下来使用
示波器和逻辑分析仪实际的抓起波形分析，具体如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000123.png)

从上图的波形图可以看出，抓取的波形符合 "PCF8574AT Read" 的规范
要求。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000124.png)

借助 DSlogic 分析仪，可以快速获得数字波形以及协议解析信息，
上图的波形符合 "PCF8574AT Read" 的要求。

----------------------------------------

###### <span id="M004">PCF8574AT 写操作</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000125.png)

上图为 PCF8574AT 的写操作时序，其时序比较简单，主控首先产生一个 START
信号，然后发送从设备地址到 I2C 总线上，并且 R/W bit 设置为 0. 发送
完毕上面数据后，主控等待从设备的应答，如果从设备将 SDA 拉低，那么表示
从设备应答，那么主控继续将第一个 byte 写到 I2C 总线上，该 byte 用于
设置 PCF8574AT 8-bit 的状态，写完第一个 byte 之后，主控等待 PCF8574AT
应答，如果从设备应答，那么接着发送第二部 byte。发送完毕之后，主控不应答
并产生一个 STOP 信号。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000030.png)

上图即是根据信号协议编写的 PCF8574AT Write。在内核中，I2C 子系统定义了
struct i2c_msg 结构为一个 I2C 帧，其定义如下：

{% highlight c %}
struct i2c_msg {
        __u16 addr;     /* slave address                        */
        __u16 flags;
#define I2C_M_RD                0x0001  /* read data, from slave to master */
                                        /* I2C_M_RD is guaranteed to be 0x0001! */
#define I2C_M_TEN               0x0010  /* this is a ten bit chip address */
#define I2C_M_DMA_SAFE          0x0200  /* the buffer of this message is DMA safe */
                                        /* makes only sense in kernelspace */
                                        /* userspace buffers are copied anyway */
#define I2C_M_RECV_LEN          0x0400  /* length will be first received byte */
#define I2C_M_NO_RD_ACK         0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK        0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_REV_DIR_ADDR      0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART           0x4000  /* if I2C_FUNC_NOSTART */
#define I2C_M_STOP              0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */
        __u16 len;              /* msg length                           */
        __u8 *buf;              /* pointer to msg data                  */
};
{% endhighlight %}

在上面的函数中，由于 PCF8574AT 只包含了一次写操作，因此只需要一个
i2c_msg 就可以完成任务，因此定义一个 i2c_msg 结构，由于写操作的
时候，R/W bit 为 0，因此给 i2c_msg 结构的 flags 添加 I2C_M_WR 标志，
由于需要写两个 byte 的数据，因此 len 设置为 2，并且 buf 只想存储
两个字节的地址.

以上准备好 i2c_msg 之后，继续调用 i2c_transfer() 函数，将 i2c_msg
传递给 I2C 核心层，最终到达 I2C 控制器的收发器上发送。接下来使用
示波器和逻辑分析仪实际的抓起波形分析，具体如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000126.png)

上图为按字节写的波形，波形符合 PCF8574AT 协议规范。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000127.png)

上图可以看出逻辑分析仪对按字节写的波形的解读，符合规范要求。

-----------------------------------------

## <span id="M192">PCF8574AT 使用</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000096.png)

开发者可以参考上面代码在内核驱动中使用 PCF8574AT。

------------------------------------------

<span id="B01"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Q.jpg)

## PCF8574AT BiscuitOS-RaspberryPi 实践部署

BiscuitOS 以及完整支持 PCF8574AT，并基于 Kbuild 编译系统，制作了一套
便捷的 PCF8574AT 开发环境，开发者可以参考如下步骤进行快速开发。

> - [PCF8574AT 源码获取](#G00)
>
> - [PCF8574AT 源码编译](#G01)
>
> - [PCF8574AT 模块安装](#G02)
>
> - [PCF8574AT DTB 安装](#G04)
>
> - [PCF8574AT 模块使用](#G03)

--------------------------------------------

#### <span id="G00">PCF8574AT 源码获取</span>

首先开发者应该准备基于 RaspberryPi 4B BiscuitOS 开发环境，并
准备好一个在 RaspberryPi 上运行的 BiscuitOS，然后使用如下命令
获得 PCF8574AT 所需的开发环境：

{% highlight bash %}
cd BiscuitOS
make RaspberryPi_4B_defconfig
make menuconfig
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000038.png)

选择 "Package --->" 并进入下一级菜单

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000128.png)

设置 "LDD: PCF8574 IO Device Driver --->" 为 "Y"。设置完毕之后，
保存并退出，

-----------------------------------------------

#### <span id="G01">PCF8574AT 源码编译</span>

PCF8574AT 的编译很简单，只需执行如下命令就可以快速编译：

{% highlight bash %}
make
cd BiscuitOS/output/RaspberryPi_4B/package/LDD_pcf8574_module-0.0.1/
make prepare
make download
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000040.png)

---------------------------------------------------

#### <span id="G02">PCF8574AT 模块安装</span>

接下来是将模块更新到 RaspberryPi 4B 上，更新的方式多种方式，可以参考下面
方式：

> - [BiscuitOS NFS 方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

--------------------------------------------

#### <span id="G04">PCF8574AT DTB 安装</span>

由于 PCF8574AT 驱动的加载需要使用 DTB，因此在编写完驱动之后，应该
修改 DTS 并生成 DTB 更新到 RaspberryPi 4B 上。如果 DTB 已经更新，
不必重复更新 DTB。DTS 的修改可以参考
"LDD_pcf8574_module-0.0.1" 目录下的 default.dts 文件，使用命令
如下:

{% highlight bash %}
cd BiscuitOS/output/RaspberryPi_4B/linux/linux/arch/arm/boot/dts
vi bcm2711-rpi-4-b.dts
{% endhighlight %}

将 PCF8574AT DTS 节点信息加入到 i2c1 节点下，如下:

{% highlight bash %}
&i2c1 {
        pinctrl-names = "default";
        pinctrl-0 = <&i2c1_pins>;
        clock-frequency = <100000>;

        pcf8574@38 {
                compatible = "BiscuitOS,pcf8574";
                reg = <0x38>;
                BD-gpio = <&gpio 25 GPIO_ACTIVE_HIGH>;
        };
};
{% endhighlight %}

修改完 DTS 之后，开发者使用如下命令编译 DTS:

{% highlight bash %}
cd BiscuitOS/output/RaspberryPi_4B/linux/linux/
make ARCH=arm CROSS_COMPILE=BiscuitOS/output/RaspberryPi_4B/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi- dtbs -j4
{% endhighlight %}

最后就是将生成的 DTB 更新到 RaspberryPi 4B 上，更新的方式
如下:

> - [BiscuitOS NFS 方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

如果采用 NFS 方式更新，在 RaspberryPi 4B 上使用如下命令:

{% highlight bash %}
mkdir -p /nfs
mount -t nfs 192.168.x.x:BiscuitOS/output/RaspberryPi_4B/ /nfs -o nolock
cp /nfs/linux/RPI_linux_github/arch/arm/boot/dts/bcm2711-rpi-4-b.dtb /boot
sync
reboot
{% endhighlight %}

在上面的命令中，192.168.x.x 为主机的 IP 地址。如果采用 SD 拷贝方式，
主机端请参考如下命令:

{% highlight bash %}
cp BiscuitOS/output/RaspberryPi_4B/linux/RPI_linux_github/arch/arm/boot/dts/bcm2711-rpi-4-b.dtb /media/XXXX/BOOT/
sync
{% endhighlight %}

在上面的命令中，XXXX 表示主机的用户名。至此 DTB 更新成功.

---------------------------------------------------

#### <span id="G03">PCF8574AT 模块使用</span>

最后就是在 BiscuitOS RaspberryPi 4B 平台上加载模块，可以参考如下命令：

{% highlight bash %}
cd /lib/modules/5.0.21-v7l\+/extra
ls
insmod i2c-bcm2835.ko
insmod pcf8574.ko
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000129.png)

------------------------------------------

<span id="B02"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L.jpg)

## PCF8574AT 工程实践部署

开发者也可以在自己的工程中部署 PCF8574AT 驱动程序，可以参考如下步骤：

> - [PCF8574AT 源码获取](#F00)
>
> - [PCF8574AT 源码编译](#F01)
>
> - [PCF8574AT 模块安装](#F02)
>
> - [PCF8574AT DTB 安装](#G04X)
>
> - [PCF8574AT 模块使用](#F03)

--------------------------------------------

#### <span id="F00">PCF8574AT 源码获取</span>

首先获得 PCF8574AT 驱动源码，使用如下命令：

{% highlight bash %}
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/kernel/pcf8574.c
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/kernel/default.dts
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/kernel/Makefile
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/kernel/Kconfig
{% endhighlight %}

> - [PCF8574AT Github 地址](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574AT/kernel)

---------------------------------------------

#### <span id="F01">PCF8574AT 源码编译</span>

获得上面的源码之后，可以采用外部模块独立编译，或者加入内核源码树进行编译，
开发者可以参考如下步骤进行编译。

###### 外部模块独立编译

此时对 Makefile 文件进行修改，其中 KERNELDIR 修改为开发者项目 Linux
源码树所在的目录。CROSS_COMPILE 变量指向交叉编译工具链所在的位置。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000130.png)

设置完毕之后，使用如下命令：

{% highlight bash %}
make
make install
{% endhighlight %}

###### 内核源码树编译

开发者也可以将驱动源码直接加入内核源码树，当加入到指定目录后，请参考 Kconfig
文件的内容，将 PCF8574AT 加入到指定目录，修改该目录下的 Kconfig 和 Makefile，
然后配置内核将 PCF8574AT 启动加入编译，使用如下命令：

{% highlight bash %}
make menuconfig ARCH=arm
make modules ARCH=arm CROSS_COMPILE=BiscuitOS/output/RaspberryPi_4B/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi-
make modules_install INSTALL_MOD_PATH=BiscuitOS/output/RaspberryPi_4B/rootfs/rootfs
{% endhighlight %}

-------------------------------------

#### <span id="F03">PCF8574AT 模块安装</span>

接下来是将模块更新到项目平台上，更新的方式多种方式，可以参考下面
方式:

> - [BiscuitOS NFS 方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

--------------------------------------------

#### <span id="G04X">PCF8574AT DTB 安装</span>

由于 PCF8574AT 驱动的加载需要使用 DTB，因此在编写完驱动之后，应该
修改 DTS 并生成 DTB 更新到 RaspberryPi 4B 上。如果 DTB 已经更新，
不必重复更新 DTB。DTS 的修改可以参考
"LDD_pcf8574_module-0.0.1" 目录下的 default.dts 文件，使用命令
如下:

{% highlight bash %}
cd BiscuitOS/output/RaspberryPi_4B/linux/linux/arch/arm/boot/dts
vi bcm2711-rpi-4-b.dts
{% endhighlight %}

将 PCF8574AT DTS 节点信息加入到 i2c1 节点下，如下:

{% highlight bash %}
&i2c1 {
        pinctrl-names = "default";
        pinctrl-0 = <&i2c1_pins>;
        clock-frequency = <100000>;

        pcf8574@38 {
                compatible = "BiscuitOS,pcf8574";
                reg = <0x38>;
		BD-gpio = <&gpio 25 GPIO_ACTIVE_HIGH>;
        };
};
{% endhighlight %}

修改完 DTS 之后，开发者使用如下命令编译 DTS:

{% highlight bash %}
cd BiscuitOS/output/RaspberryPi_4B/linux/linux/
make ARCH=arm CROSS_COMPILE=BiscuitOS/output/RaspberryPi_4B/arm-linux-gnueabi/arm-linux-gnueabi/bin/arm-linux-gnueabi- dtbs -j4
{% endhighlight %}

最后就是将生成的 DTB 更新到 RaspberryPi 4B 上，更新的方式
如下:

> - [BiscuitOS NFS 方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新模块](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

如果采用 NFS 方式更新，在 RaspberryPi 4B 上使用如下命令:

{% highlight bash %}
mkdir -p /nfs
mount -t nfs 192.168.x.x:BiscuitOS/output/RaspberryPi_4B/ /nfs -o nolock
cp /nfs/linux/RPI_linux_github/arch/arm/boot/dts/bcm2711-rpi-4-b.dtb /boot
sync
reboot
{% endhighlight %}

在上面的命令中，192.168.x.x 为主机的 IP 地址。如果采用 SD 拷贝方式，
主机端请参考如下命令:

{% highlight bash %}
cp BiscuitOS/output/RaspberryPi_4B/linux/RPI_linux_github/arch/arm/boot/dts/bcm2711-rpi-4-b.dtb /media/XXXX/BOOT/
sync
{% endhighlight %}

在上面的命令中，XXXX 表示主机的用户名。至此 DTB 更新成功.

-------------------------------------

#### <span id="F04">PCF8574AT 模块使用</span>

最后就是在开发平台上加载模块，可以参考如下命令：

{% highlight bash %}
cd /lib/modules/5.0.21-v7l\+/extra
ls
insmod i2c-bcm2835.ko
insmod pcf8574.ko
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000129.png)

------------------------------------------

<span id="A0120"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000M.jpg)

## i2cdetect

i2cdetect 工具用于探测指定 I2C 总线上所有 I2C 从设备，如果
指定 I2C 地址存在 I2C 设备，那么会将 I2C 从设备地址标记在结果
里。i2cdetect 使用如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000059.png)

如上图，i2cdetect 找到了 PCF8574AT 的多个从设备地址。i2cdetect 工具的
参数中，"-y" 用于指定 I2C 总线的编号.

------------------------------------------

<span id="A0121"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000B.jpg)

## i2cdump

i2cdump 工具用于打印指定 I2C 总线上指定从设备上的所有数据，该
工具用于 I/O Expander 的数据查看，i2cdump 使用如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000060.png)

如上图，使用 i2cdump 工具查看 PCF8574AT 上的所有数据. 该工具对快速读取
I2C 设备上数据有帮助。

------------------------------------------

<span id="A0122"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000S.jpg)

## i2cget

i2cget 工具用于从指定 I2C 总线的从设备上读取指定位置的值，
在开发过程中，需要对从设备的某个寄存器进行读取操作，这个
工具再适合过不，其使用如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000071.png)

在使用 i2cget 工具的时候，"-y" 参数后面匹配 I2C 总线编号，如上图
中查找的是 I2C1 总线; 接下来的参数是 I2C 从设备地址和内部偏移地址。

------------------------------------------

<span id="A0123"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000W.jpg)

## i2cset

与 i2cget 工具相对应的工具就是 i2cset, 该工具用于在指定 I2C 总线
上，给特定的 I2C 从设备的内部地址进行写操作, 其使用如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000072.png)

在使用 i2cset 工具的时候，"-y" 参数后面匹配 I2C 总线编号，如上图
查找的是 I2C1 总线；接下来的参数是 I2C 从设备地址，以及内部要写
的地址，最后是要写的内容。


------------------------------------------

<span id="A013"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Z.jpg)

## PCF8574AT 应用程序

BiscuitOS 为 PCF8574AT 提供了完整的应用程序支持，开发者可以参考本节
内容，对 PCF8574AT 应用程序进行实践部署。

> - [PCF8574AT 应用程序分析](#B03)
>
>   - [PCF8574AT I2C 接口](#K38)
>
>     - [PCF8574AT 随机地址读操作](#K001)
>
>     - [PCF8574AT 连续读操作](#K002)
>
>     - [PCF8574AT 当前地址读操作](#K003)
>
>     - [PCF8574AT 按字节写操作](#K004)
>
>     - [PCF8574AT 按页写操作](#K005)
>
>   - [PCF8574AT 使用](#K28)
>
> - [PCF8574AT BiscuitOS-RaspberryPi 中使用](#B04)
>
> - [PCF8574AT 工程实践部署](#B05)

------------------------------------------

<span id="B03"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000N.jpg)

## PCF8574AT 应用程序分析

BiscuitOS 已经支持最新的 PCF8574AT 芯片，开发者可以使用 BiscuitOS 提供
的应用程序 PCF8574AT 进行使用，驱动源码 GithuB 地址如下：

> - [PCF8574AT I/O Expander Application for BiscuitOS](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574AT/userland)
>
> - [PCF8574AT Datasheet](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/PCF8574AT.pdf)

BiscuitOS 提供的完整应用程序如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000073.png)

应用程序分作两个部分，第一部分是 PCF8574AT 提供 I/O Expander 的读写接口;
第二部分是驱动对 I/O Expander 的使用。接下来的内容将详细分析每一部分代码的构成。

> - [PCF8574AT I2C 接口](#K38)
>
> - [PCF8574AT 使用](#K28)

-----------------------------------------------

#### <span id="K38">PCF8574AT I2C 接口</span>

通过 PCF8574AT 的数据手册可以知道，PCF8574AT 提供了一种方式的读，也
只提供了一种方式的写。接下里分别介绍每种操作如何编写代码。

> - [PCF8574AT 读操作](#K001)
>
> - [PCF8574AT 写操作](#K004)

---------------------------------------

###### <span id="K001">PCF8574AT 随机地址读操作</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000122.png)

上图定义了 PCF8574AT 的 I2C 总线读操作时序，从上图的定义可以看出，
在主控产生一个 START 信号之后，只需发送向 I2C 总线上发送 PCF8574AT
的从设备地址，并且 R/W bit 设置为 1 即可，此时如果 PCF8574AT 收到
主控发来的请求之后，会通过拉低 SDA 总线产生一个 ACK 应答信号，此时
主控收到应答信号之后，就等待 PCF8574AT 发送两个 Byte 的数据。PCF8574AT
产生第一个 ACK 应答之后，会向 SDA 总线上发送一个 BYTE 的数据，该数据
就是当前 8-bit I/O 的状态，接着采用同样的方式，拉低 ACK 再发送一次
8-bit I/O 的状态。发送完毕两 Byte 的数据之后，主控产生一个 STOP 信息
结束本次读操作。值得注意的是，PCF8574AT 在发送完第一个 BYTE 数据之后，
会在 INT 引脚上产生一个时长为 Tir 的中断。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000027.png)

上图即是根据信号协议编写的 Read 操作函数。在内核中，I2C 子系统定义了
struct i2c_msg 结构为一个 I2C 帧，其定义如下：

{% highlight c %}
struct i2c_msg {
        __u16 addr;     /* slave address                        */
        __u16 flags;
#define I2C_M_RD                0x0001  /* read data, from slave to master */
                                        /* I2C_M_RD is guaranteed to be 0x0001! */
#define I2C_M_TEN               0x0010  /* this is a ten bit chip address */
#define I2C_M_DMA_SAFE          0x0200  /* the buffer of this message is DMA safe */
                                        /* makes only sense in kernelspace */
                                        /* userspace buffers are copied anyway */
#define I2C_M_RECV_LEN          0x0400  /* length will be first received byte */
#define I2C_M_NO_RD_ACK         0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK        0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_REV_DIR_ADDR      0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART           0x4000  /* if I2C_FUNC_NOSTART */
#define I2C_M_STOP              0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */
        __u16 len;              /* msg length                           */
        __u8 *buf;              /* pointer to msg data                  */
};
{% endhighlight %}

根据 PCF8574AT 读时序，主控只需发送一个 i2c_msg 即可，因此定义了
一个 i2c_msg 结构，由于读时序的时候，R/W bit 置位，因此给 i2c_msg
结构的 flags 添加 I2C_M_RD 标志，以此表示该 i2c_msg 用于读操作。
接着根据主控发送 i2c_msg 之后，PCF8574AT 会返回两个 byte 的字节，
因此将 i2c_msg 的 len 设置为 2， 并且 buf 只想一个可以存储 2 个字节
的内存地址。

以上准备好 i2c_msg 之后，继续调用 ioctl() 函数，将 i2c_msg
传递给 I2C 核心层，最终到达 I2C 控制器的收发器上发送。接下来使用
示波器和逻辑分析仪实际的抓起波形分析，具体如下

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000123.png)

从上图的波形图可以看出，抓取的波形符合 "PCF8574AT Read" 的规范
要求。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000124.png)

借助 DSlogic 分析仪，可以快速获得数字波形以及协议解析信息，
上图的波形符合 "PCF8574AT Read" 的要求。

--------------------------------------------

###### <span id="K004">PCF8574AT 写操作</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000125.png)

上图为 PCF8574AT 的写操作时序，其时序比较简单，主控首先产生一个 START
信号，然后发送从设备地址到 I2C 总线上，并且 R/W bit 设置为 0. 发送
完毕上面数据后，主控等待从设备的应答，如果从设备将 SDA 拉低，那么表示
从设备应答，那么主控继续将第一个 byte 写到 I2C 总线上，该 byte 用于
设置 PCF8574AT 8-bit 的状态，写完第一个 byte 之后，主控等待 PCF8574AT
应答，如果从设备应答，那么接着发送第二部 byte。发送完毕之后，主控不应答
并产生一个 STOP 信号。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000030.png)

上图即是根据信号协议编写的 PCF8574AT Write。在内核中，I2C 子系统定义了
struct i2c_msg 结构为一个 I2C 帧，其定义如下：

{% highlight c %}
struct i2c_msg {
        __u16 addr;     /* slave address                        */
        __u16 flags;
#define I2C_M_RD                0x0001  /* read data, from slave to master */
                                        /* I2C_M_RD is guaranteed to be 0x0001! */
#define I2C_M_TEN               0x0010  /* this is a ten bit chip address */
#define I2C_M_DMA_SAFE          0x0200  /* the buffer of this message is DMA safe */
                                        /* makes only sense in kernelspace */
                                        /* userspace buffers are copied anyway */
#define I2C_M_RECV_LEN          0x0400  /* length will be first received byte */
#define I2C_M_NO_RD_ACK         0x0800  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_IGNORE_NAK        0x1000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_REV_DIR_ADDR      0x2000  /* if I2C_FUNC_PROTOCOL_MANGLING */
#define I2C_M_NOSTART           0x4000  /* if I2C_FUNC_NOSTART */
#define I2C_M_STOP              0x8000  /* if I2C_FUNC_PROTOCOL_MANGLING */
        __u16 len;              /* msg length                           */
        __u8 *buf;              /* pointer to msg data                  */
};
{% endhighlight %}

在上面的函数中，由于 PCF8574AT 只包含了一次写操作，因此只需要一个
i2c_msg 就可以完成任务，因此定义一个 i2c_msg 结构，由于写操作的
时候，R/W bit 为 0，因此给 i2c_msg 结构的 flags 添加 I2C_M_WR 标志，
由于需要写两个 byte 的数据，因此 len 设置为 2，并且 buf 只想存储
两个字节的地址.

以上准备好 i2c_msg 之后，继续调用 ioctl() 函数，将 i2c_msg
传递给 I2C 核心层，最终到达 I2C 控制器的收发器上发送。接下来使用
示波器和逻辑分析仪实际的抓起波形分析，具体如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000126.png)

上图为按字节写的波形，波形符合 PCF8574AT 协议规范。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000127.png)

上图可以看出逻辑分析仪对按字节写的波形的解读，符合规范要求。

-----------------------------------------------

#### <span id="K28">PCF8574AT 使用</span>

有了上面的接口之后，开发者可以在用户空间参考下面代码对 PCF8574AT 使用:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000079.png)

在上面的代码中，可以在 PCF8574AT 的 GPIO1 上接一个 LED 灯，
以此直观的感受 GPIO 的状态变化，如下图:

![](https://gitee.com/BiscuitOS_team/GIFBase/raw/master/RPI/RPI000001.GIF)

------------------------------------------

<span id="B04"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Q.jpg)

## PCF8574AT BiscuitOS-RaspberryPi 中使用

BiscuitOS 以及完整支持 PCF8574AT，并基于 Kbuild 编译系统，制作了一套
便捷的 PCF8574AT 开发环境，开发者可以参考如下步骤进行快速开发。

> - [PCF8574AT 源码获取](#GK00)
>
> - [PCF8574AT 源码编译](#GK01)
>
> - [PCF8574AT 应用安装](#GK02)
>
> - [PCF8574AT 应用使用](#GK03)

--------------------------------------------

#### <span id="GK00">PCF8574AT 源码获取</span>

首先开发者应该准备基于 RaspberryPi 4B BiscuitOS 开发环境，并
准备好一个在 RaspberryPi 上运行的 BiscuitOS，然后使用如下命令
获得 PCF8574AT 所需的开发环境：

{% highlight bash %}
cd BiscuitOS
make RaspberryPi_4B_defconfig
make menuconfig
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000038.png)

选择 "Package --->" 并进入下一级菜单

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000131.png)

设置 "LDD: PCF8574AT Application --->" 为 "Y"。设置完毕之后，
保存并退出，

-----------------------------------------------

#### <span id="GK01">PCF8574AT 源码编译</span>

PCF8574AT 的编译很简单，只需执行如下命令就可以快速编译：

{% highlight bash %}
make
cd BiscuitOS/output/RaspberryPi_4B/package/LDD_pcf8574_app-0.0.1/
make prepare
make download
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000081.png)

---------------------------------------------------

#### <span id="GK02">PCF8574AT 模块安装</span>

接下来是将模块更新到 RaspberryPi 4B 上，更新的方式多种方式，可以参考下面
方式：

> - [BiscuitOS NFS 方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

--------------------------------------------

#### <span id="GK03">PCF8574AT 应用程序的使用</span>

最后就是在 BiscuitOS RaspberryPi 4B 平台上加载模块，可以参考如下命令：

{% highlight bash %}
cd /lib/modules/5.0.21-v7l\+/extra
insmod i2c-bcm2835.ko
insmod i2c-dev.ko
LDD_pcf8574_app-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/GIFBase/raw/master/RPI/RPI000001.GIF)

------------------------------------------

<span id="B05"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L.jpg)

## PCF8574AT 工程实践部署

开发者也可以在自己的工程中部署 PCF8574AT 应用程序，可以参考如下步骤：

> - [PCF8574AT 源码获取](#FK00)
>
> - [PCF8574AT 源码编译](#FK01)
>
> - [PCF8574AT 应用安装](#FK02)
>
> - [PCF8574AT 应用使用](#FK03)

--------------------------------------------

#### <span id="FK00">PCF8574AT 源码获取</span>

首先获得 PCF8574AT 应用源码，使用如下命令：

{% highlight bash %}
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/userland/pcf8574.c
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/userland/pcf8574.sh
wget https://raw.githubusercontent.com/BiscuitOS/HardStack/master/Device-Driver/i2c/Device/PCF8574AT/userland/Makefile
{% endhighlight %}

> - [PCF8574AT Github 地址](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574/userland)

---------------------------------------------

#### <span id="FK01">PCF8574AT 源码编译</span>

获得上面的源码之后，开发者只需提供编译工具，就可以直接编译源码，
此时对 Makefile 文件进行修改，其中 CROSS_COMPILE 变量指向交叉编
译工具链所在的位置。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000083.png)

设置完毕之后，使用如下命令：

{% highlight bash %}
make
make install
{% endhighlight %}

-------------------------------------

#### <span id="FK02">PCF8574AT 应用安装</span>

接下来是将应用更新到项目平台上，更新的方式多种方式，可以参考下面
方式:

> - [BiscuitOS NFS 方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

-------------------------------------

#### <span id="FK03">PCF8574AT 应用使用</span>

最后就是在开发平台上加载模块，可以参考如下命令：

{% highlight bash %}
cd /lib/modules/5.0.21-v7l\+/extra
ls
insmod i2c-bcm2835.ko
insmod pcf8574.ko
LDD_pcf8574_app-0.0.1
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L.jpg)

------------------------------------------

<span id="B10"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000E.jpg)

## PCF8574AT 问题合集

> - [I2C 总线无法找到 PCF8574AT](#C00)
>
> - [PCF8574AT 多次读失败](#CD00)

----------------------------------------------

<span id="C00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000K.jpg)

## I2C 总线无法找到 PCF8574AT

将 PCF8574AT 连接到 RPI-4B 的 I2C-1 总线上，具体连接如下图，PCF8574AT
模块 VCC 连接到 RPI-4B 1 号脚 VCC；GND 连接到 RPI-4B 9 号脚；SDL 连接到
RPI-4B 5 号脚；SDA 连接到 RPI-4B 3 号脚。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000008.png)

接着在 RPI-4B 上，I2C 总线注册使用的是 /dev/i2c-1, 此时使用 BiscuitOS
系统上自带的工具 i2cdetect 对 I2C-1 总线进行 detect 操作，运行
结果如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000009.png)

从结果可以看出 i2cdetect 工具并未在 I2C-1 总线上找到任何从设备。
接着使用测试程序对 PCF8574AT 进行读操作，测试代码如下：

> - [测试代码 Github 位置](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Error/Detect/userland)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000010.png)

基于上面的代码，使用 DSCope 示波器对 SDL 和 SDA 信号进行抓取，更多
DSCope 的使用请参阅下面文档：

> - [DSCope 用户手册]()

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000013.jpg)

在抓取波形之前，先分析一下 PCF8574AT I2C 读操作的信号定义，PCF8574AT 数据手册
请参阅：

> - [PCF8574AT I/O Expander](https://github.com/BiscuitOS/Documentation/blob/master/Datasheet/I2C/PCF8574AT.pdf)

其中对应读操作，代码中使用的是 AT24C98 的 Random Read，其信号定义如下：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000014.png)

在 PCF8574AT 的 Random Read 信号中，首先是 START 信号，该信号是 SDA 首先产生
一个下降沿，如果此时 SCL 任处于高电平，那么 I2C 认为其为 START 信号。如下图：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000015.png)

START 信号之后，I2C Master 传递 7 bit 的 Slave 地址，Slave 地址首先传 MSB
部分，即 Slave 地址的高字节，然后传低字节。传递完毕之后是 W/R 标志位，此时
W/R bit 位为低电平，W/R 位为低代表写操作。W/R 信号之后是 ACK 信号，此时如
果指定的 Slave 设备没有应答，那么 ACK 将会是高电平，此时 Master 会重传一次
指定 Slave 设备的地址，如果 Slave 设备还是没有应答，那么 Master 就发出一个
STOP 信号；如果指定的 Slave 设备应答，那么 ACK 信号会将 SDA 拉低。ACK 信号
之后是 8 bit 的读地址，即需要在 PCF8574AT 上读取数据的地址，其也是先传 MSB
到 LSB 的传信号。至此，之前传输的信号称为 "DUMMY WRITE"，因为在这段信号中，
W/R 信号为低，代表一次写，但又不是 I2C 写操作，因此称为假的写操作。接下来
Master 继续产生一个 START 信号，并再次按 MSB 到 LSB 的方式传输从设备的地址。
接下来传递一个 READ 信号，为高电平，代表真正的读操作，此时如果 Slave 设备准备
好数据，那么 Slave 设备就会将 SDA 总线拉低，以此生成一个 ACK 信号，接着
Slave 设备将数据写入到 SDA 信号线上；如果此时 Slave 设备没有应答，那么 Master
会重传 Slave 地址到 SDA 信号线上。在 Slave 设备传输完数据之后，如果
没有其他操作，那么到第 9 个周期 Slave 将不会产生 ACK 信号，SDA 信号线变高，
此时如果 Master 无其他操作，那么 Master 将会产生一个 STOP 信号。至此，一次
I2C 的 Random Read 操作完成。

#### 无 Slave 设备 I2C Read 操作

首先在 I2C 总线上不挂载任何从设备的情况下，进行 I2C 的 Random Read 操作。
搭建好测试环境之后，运行 DSView 程序。点击触发按钮，将右侧 "触发位置" 调整
为 10%，以便能从 I2C 起始信号处开始抓取波形；此时通道 0 连接 SDA 信号线，根据
I2C 信号可知，当 SDA 产生一个下降沿之后，SCL 接着也产生一个下降沿，那么认为
是 I2C 开始传输信号，因此将 SDA 的下降沿作为触发信号。设置好之后点击 "单次"
按钮，对信号进行捕捉。使用上面的测试程序，对 0x50 的 0x00 地址读取 1 个字节
的操作：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000006.png)

从捕获的波形可以看出，绿色为 SCL 信号，黄色为 SDA 信号。在前 8 个周期中，
从设备地址为 0x50，R/W 为 0，ACK 没有应答，因此 Master 在重发一次，此时
ACK 还是没有应答，于是 Master 发送一个 STOP 信号。此次操作预计结果符合预期。

#### 挂载 PCF8574AT I2C Read 操作

首先将 PCF8574AT 连接到 RPI-4B 上，进行 I2C 的 Random Read 操作。
搭建好测试环境之后，运行 DSView 程序。点击触发按钮，将右侧 "触发位置" 调整
为 10%，以便能从 I2C 起始信号处开始抓取波形；此时通道 0 连接 SDA 信号线，根据
I2C 信号可知，当 SDA 产生一个下降沿之后，SCL 接着也产生一个下降沿，那么认为
是 I2C 开始传输信号，因此将 SDA 的下降沿作为触发信号。设置好之后点击 "单次"
按钮，对信号进行捕捉。使用上面的测试程序，对 0x50 的 0x00 地址读取 1 个字节
的操作：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000007.png)

从捕获的波形可以看出，绿色为 SCL 信号，黄色为 SDA 信号。在前 8 个周期中，
从设备地址为 0x50，R/W 为 0，ACK 没有应答，因此 Master 重传了一次，到了
第 9 个周期还是没有应答。因此发现问题 Slave 设备无法识别。

#### 问题排除

首先使用电压表测量 PCF8574AT 的电压，VCC 为 3.2V，SDA 与 SCL 均为 3.1V：
在这听取社区朋友的建议，对 RPI 4B I2C 的频率进行修改，分别测试了 400K, 100K,
50K, 以及 10K，都无法找到 I2C 从设备。
接着查看 BCM2835 关于 I2C 控制器的文档，以及对应的的驱动程序，在其中发现一个
名为 "Clock Stretching" 的问题，即由于主控在 I2C 总线上向从设备发送数据之后，
从设备回应时间超过了 Master 等待时间，这称为时钟拉升问题。下面是对该问题的讨论：

> - [Raspberry Pi I2C clock-stretching bug](http://www.advamation.com/knowhow/raspberrypi/rpi-i2c-bug.html)
>
> - [I2C clock stretching](https://www.raspberrypi.org/forums/viewtopic.php?p=146272)

通过上面的文档，也发现了挂载 PCF8574AT 的时候，也出现了周期拉升问题，如下图：

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000007.png)

因此确定问题就是 Master 正常发送波形，只是 Slave 没有或者没有及时应答，
因此继续查找根本原因。于是我找了一个高速的 I2C 设备 "LM75A" 高精度温度
传感器。使用同样的安装办法，结果还是同样的问题，RPI 4B 无法找到 Slave
设备。

社区朋友建议在 PCF8574AT 芯片引脚上确认是否有 SDA 和 SCL 信号传输过来，
结果通过示波器发现 SCL 信号并未接收到，于是排查链接问题。最后发现连接
PCF8574AT 的杜邦线头处出现松动，导致虚接。将线连接好后，RPI 4B 可以正常
找到 Slave 设备。

#### 问题总结

为了处理这个问题，花费了很多时间查找各方面的原因，通过不断的查找，离真相越来
越近。最后发现问题是因为杜邦线连接问题，这里曾经是自己没有实际测量但认为
没有问题的地方，最后这里成为问题的根本原因。通过这次问题的解决，虽然绕了
一大圈，但对 I2C 的多个方面也有了更多的理解，比如 I2C 控制器，I2C 平台总线，
I2C 设备方面。但最终问题还是由于自己对硬件连线处理不够谨慎引起的。

----------------------------------------------

<span id="CD00"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000M.jpg)

## PCF8574AT 多次写失败

在用户空间使用 "Byte Write" 的方式向 PCF8574AT 指定地址不停的写入指定值，
发现写入失败，此时 I2C 总线的频率是 100K，使用的测试代码如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000092.png)

> - [完整问题代码 GitHub 链接](https://github.com/BiscuitOS/HardStack/tree/master/Device-Driver/i2c/Device/PCF8574AT/Test/WritePress)

使用上面的代码进行测试，运行测试程序如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000089.png)

-------------------------------

#### 问题分析

PCF8574AT "Byte Write" 的时序定义如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000025.png)

测试程序对 "Byte Write" 的详细分析请看下面文档:

> - [PCF8574AT 用户空间 Byte Write 操作](K004)

当发生错误的时候，使用逻辑分析仪抓到的时序信号如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000093.png)

从上面的 I2C 信号图可以看出，主控第一次向 PCF8574AT 的第一次写
是成功的，但是第二次主控向 I2C 总线写的时候 I2C 总线处于忙状态，
因此可以猜测由于应用程序写的太快，I2C 控制器还没有将前一帧数据
写完，第二帧数据就到来。

-----------------------------------

#### 问题解决

通过上面的分析，只需在两次写操作或者一次写操作后面加上一定的延时，
让 I2C 主控能将数据帧发送完毕。但问题来了，延时的时长多长？其实
在嵌入式领域，延时的使用是很常见的，其计算可以大概按下列方法:

{% highlight bash %}
1. 假设 I2C 总线的频率为 M (M 通常的数值为 400K、100K、50K etc)，
   那么 I2C 控制器发送一个 bit 所需的时间计算为:

     T_bit = (1 / M)

2. 应用程序中，使用 "Byte Write" 的方式写操作，一个完整的 "Byte Write"
   帧至少包含 30 个 bit, 因此 I2C 控制器发送一个完整 "Byte Write" 帧
   所需的时间为:

     T_bw = 30 * T_bit

3. 因此，每次 "Byte Write" 之后都应该有 T_bw 的延时，至于使用什么延时
   函数，依实际开发而定。
{% endhighlight %}

通过上面的分析，解决问题可以按如下步骤。首先 I2C 总线的频率是 100K，
因此此时:

{% highlight bash %}
T_bit = 1 / (100 * 1024)
T_bit = 0.000009766
{% endhighlight %}

所以 I2C 控制器发送一个 bit 大概需要 0.009 毫秒，接着计算在这种情况下
一个完整的 "Byte Write" 所需的时间如下:

{% highlight bash %}
T_bw = 30 * T_bit
T_bw = 30 * 0.000009766
T_bw = 0.000292969
{% endhighlight %}

通过上面的计算，一次完整的 "Byte Write" 所需的时间是 0.3 毫秒，因此
在代码中添加如下代码:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000025.png)

代码中使用 usleep() 函数，usleep() 的延时单位是微妙 (百万分之一秒).
更新新代码并在 RaspberryPi 4B 上进行测试，测试结果如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000095.png)

程序已经正常运行，从抓起的波形可以看出 "Byte Write" 已经成功执行.

-----------------------------------

#### 问题总结

当遇到 I2C 总线忙或者读写失败的问题，可以从延时这里切入。

------------------------------------------

<span id="F000"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000T.jpg)

## PCF8574AT 进阶研究

> - [PCF8574AT 中断使用问题](#F0001)

------------------------------------------

<span id="F0001"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000M.jpg)

## PCF8574AT 中断使用问题

#### 课题简介

正如上图所示，在 PCF8574AT 8-bit I/O 状态改变的情况下，会触发一个
中断，因此在有需要使用 GPIO 中断的应用中，可以参照本节内容。为了
更好的演示中断的使用，这里使用一个按钮，并将其接到 PCF8574AT 任意
一个 GPIO 上，如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000132.png)

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000132.png)

按钮不按下的时候输出高电平，按下的时候输出低电平，输出低电平。




![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000097.png)

上面对于 PCF8574AT 多从设备地址的解释是这样的，PCF8574AT 为了能访问 8K 的存储
空间，那么 PCF8574AT 会将 A0 和 A1 引脚悬空，与设备地址的 8 位地址一起组成一
个 10 位地址，且 A1，A2 作为高地址，如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000098.png)

-----------------------------------------

#### 课题分析

PCF8574AT 访问 8K I/O Expander 空间，那么 P1、P0 则作为设备内部地址，
而 A2 引脚作为片选，也就是同一个 I2C 总线上只能同时接 2 个
PCF8574AT，并且第一个 PCF8574AT 的 A2 引脚接地，第二个 PCF8574AT
的 A2 引脚上拉接 VCC，这样就可以区分两块 PCF8574AT. 接着每块
PCF8574AT 的 A1，A2 与设备的 8 位地址一同组成 10 位的设备内部
偏移地址，如下:

{% highlight ruby %}
设备地址  =  A1:A0:8bit
{% endhighlight %}

PCF8574AT 一共有 4 个从设备地址: 0x50, 0x51, 0x52, 0x53.
每个从设备地址指向 2K 的 I/O Expander 空间。例如 PCF8574AT 从设备地址
0x50 对应第一块 2K bits 的 I/O Expander 空间，其使用 10 bit 的设备
地址寻址，这 10 bit 设备地址由 PCF8574AT 的 A1、A0 和 8bit 设备
地址构成，由于从设备地址为 0x50，则 A1, A0 均为 0，因此只能
使用 8bit 的设备地址访问第一块 2K I/O Expander 空间，其寻址范围
是 "0x00000000 - 0x00FFFF"；同理 PCF8574AT 从设备地址为 0x51,
其 A1 为 0，A0 为 1，那么剩余的 8bit 作为第二块 2K I/O Expander 的
内部偏移地址；同理 PCF8574AT 从设备地址为
0x52, 其 A1 为 1，A2 为 0，那么剩余的 8bit 作为第三块
I/O Expander 的内部偏移地址。通过上面的的分析，PCF8574AT 地址空间
分布与从设备地址的关系如下:

{% highlight ruby %}
从设备地址             地址范围
0x50                  0x00000000 - 0x0000FFFF
0x51                  0x00010000 - 0x0001FFFF
0x52                  0x00020000 - 0x0002FFFF
0x53                  0x00030000 - 0x0003FFFF
{% endhighlight %}

-------------------------------------------

#### 课题实践

通过上面的分析，在用户空间使用程序对上面的代码进行验证，完整代码如下:

> - [PCF8574AT 多从设备地址问题实践源码 GitHub 链接]()
>
> - [PCF8574AT 测试源码使用方法]()

------------------------------------------

<span id="F0002"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000Y.jpg)

## PCF8574AT 回滚问题

#### 课题简介

------------------------------------------

<span id="A016"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000P.jpg)

## PCF8574AT 工程应用

工程实践中经常使用 PCF8574AT 用于特定的任务，本节用于介绍 PCF8574AT I/O Expander
的工程应用:

> - [潘多拉魔盒](#G000)

------------------------------------------

<span id="G000"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000W.jpg)

## 潘多拉魔盒

潘多拉的盒子，来源于希腊神话。潘多拉是一个美女，她有一个盒子，
所以这个盒子就被叫作潘多拉的盒子。她的盒子里装着很多坏东西和很多好东西。
但她只放出了坏东西，没放出好东西，导致人间有了很多灾难。
PCF8574AT I/O Expander 也经常在工程中用来存储很多重要内容，比如用户密码，
账号，IP、MAC，ID、配置信息等，这些信息对个人隐私有着至关重要的
作用，如果不妥善管理，一但泄露不堪设想。因此本节用于介绍一个完整
的 PCF8574AT 工程运用。

> - [实现原理](#G0000)
>
> - [实践部署](#G0001)
>
> - [使用说明](#G0002)
>
> - [项目融合](#G0003)

------------------------------------------

#### <span id="G0000">实现原理</span>

PCF8574AT I/O Expander 具有掉电不丢失数据，采用 I2C 接口进行数据通信，具有
8Kbit 的存储空间，将 ERRPOM 的存储空间进行规划，使其满足开发者工程
需要。

--------------------------------------------

#### <span id="G0001">实践部署</span>

BiscuitOS 支持一键部署 "潘多拉魔盒", 开发者请参考如下命令：

{% highlight bash %}
cd BiscuitOS
make RaspberryPi_4B_defconfig
make menuconfig
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000099.png)

选择并进入 "Package --->"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000100.png)

选择并进入 "LDD: PCF8574AT Chest --->"

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000101.png)

最后保存并退出，执行下列命令:

{% highlight bash %}
cd BiscuitOS
make
cd BiscuitOS/output/RaspberryPi_4B/package/LDD_pcf8574_chest-0.0.1/
make prepare
make download
make
make install
make pack
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000102.png)

至此，项目编译已经完成，接下来的将 "潘多拉" 魔盒安装到指定硬件平台，
本文例子运行在 RaspberryPi 4B 上，具体应用程序安装请参考如下内容:

> - [BiscuitOS NFS 方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020140)
>
> - [BiscuitOS SD 卡方式更新](https://biscuitos.github.io/blog/RaspberryPi_4B-Usermanual/#A020141)

-----------------------------------------------

#### <span id="G0002">使用说明</span>

将应用程序安装到硬件平台后，可以使用如下命令查看工具的使用方法:

{% highlight bash %}
LDD_pcf8574_chest-0.0.1 -h
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000103.png)

例如开发者可以存储一个密码，并读出最新的密码:

{% highlight bash %}
LDD_pcf8574_chest-0.0.1 -w password root

LDD_pcf8574_chest-0.0.1 -r password
{% endhighlight %}

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/RPI/RPI000104.png)

同理开发者可以修改获得更新 IP, MAC, boolean, int, string 等类型
数据，更多使用方法请查看其帮助。

-----------------------------------------------

#### <span id="G0003">项目融合</span>

开发者在将 "潘多拉魔盒" 移植到自己的硬件平台，需要添加一些新的项，
此时开发者只需修改 "src/user_command.c" 文件，向 cmd_lists[]
数组中添加一个新的成员就可以，例如添加一个项，用于存储账号名字，
于是可以添加代码如下:

{% highlight c %}

struct chest_cmd_struct cmd_lists[] = {

...

    {
         .type        = CMD_TYPE_STRING,
         .eeprom_addr = 0x50,
         .len         = 10,
         .cmdline     = "name",
         .desc        = "User name",
    },

...

};

{% endhighlight %}

然后重新编译代码，就可以使用这个项目了。

-----------------------------------------------

# <span id="A017">附录</span>

> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [BiscuitOS Driver](https://biscuitos.github.io/blog/BiscuitOS_Catalogue/)
>
> [BiscuitOS Kernel Build](https://biscuitos.github.io/blog/Kernel_Build/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)
>
> [搭建高效的 Linux 开发环境](https://biscuitos.github.io/blog/Linux-debug-tools/)

## 捐赠支持一下吧 🙂

![MMU](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/HAB000036.jpg)
