---
layout: post
title:  "系统调用: open()"
date:   2019-12-12 09:23:30 +0800
categories: [HW]
excerpt: SysCall open.
tags:
  - [SysCall]
---

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L0.PNG)

> Email: BuddyZhang1 <buddy.zhang@aliyun.com>

## 目录

> - [Open 系统调用原理](#A0)
>
> - [Open 系统调用实践](#B0)
>
> - [Open 源码分析](#C0)
>
> - [Open 进阶研究](#D0)
>
> - [附录/捐赠](#Z0)

----------------------------------

<span id="A0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000P.jpg)

## Open 系统调用原理

## 重要数据结构

> - [struct filename](#A00010)
>
> - [struct files_struct](#A00011)
>
> - [struct fdtable](#A00012)
>
> - [struct nameidata](#A00013)
>
> - [struct path](#A00014)
>
> - [struct qstr](#A00015)
>
> - [filp_cachep](#A00016)
>
> - [open_flags](#A00017)


-------------------------------------

#### <span id="A00010">struct filename</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000021.png)

"struct filename" 结构定义在 "include/linux/fs.h"，用于管理
用户空间传递下来的路径名。成员 name 用于指向用户空间路径名拷贝到
内核空间的位置; 参数 uptr 用于指向用户空间文件路径名; 参数
refcnt 用于指定该文件路径名引用的次数; aname 参数用于内核的
审计功能，如果没有启用 CONFIG_AUDIT, 那么该成员设置为 NULL;
参数 iname 为一个字符数组，如果采用下面介绍的第一种管理方式，
那么该成员和成员 name 一致指向用户空间路径名拷贝到内核空间的
位置，如果采用第二种管理方式，那么该成员不使用。

###### 内核文件路径名管理策略

内核采用两种方式管理文件路径名，第一
种针对的是文件路径名长度小于 EMBEDDED_NAME_MAX 的文件路径名，
内核从 names_cachep 缓存中分配大小为 PATH_MAX 的内存空间，
"struct filename" 结构占用了这部分内存的头部，剩余的部分用于
存储从用户空间传递下来的路径名，如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000001.png)

第二种针对文件路径名长度大于等于 EMBEDDED_NAME_MAX 而小于 
PATH_MAX 的情况，这种情况下，内核首先从 names_cachep 中分配
一个缓存，其长度也是 PATH_MAX, 然后再从 SLAB 中分配一个
"struct filename" 大小的内存，使用这个 "struct filename" 
的 name 成员指向了从 names_cachep 中分配出来的内存，这个内存
就用来存储用户空间传递下来的文件路径名，其逻辑如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000002.png)

-----------------------------------

#### <span id="A00011">struct files_struct</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000022.png)

-----------------------------------

#### <span id="A00012">struct fdtable</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000023.png)

struct fdtable 数据结构用于管理和维护当前进程的文件描述符。在 Linux 内核
中，使用一个整数表示文件描述符，对于同一个进程，进程可以使用唯一的
文件描述符管理一个打开的文件; 而对于不同的两个或多个进程，虽然文件
描述符相同，但不一定指向同一个打开的文件。因此文件描述符再进程内讨论
才有意义。struct fdtbale 结构的 max_fds 用于表示当前进程支持的最大
文件描述符数; close_on_exec 成员是一个 bitmap，每个 bitmap 对应一个
文件描述符，每个 bit 的代表一个打开的文件描述符，用于确定在调用系统调
用 execve() 时需要关闭的文件句柄。当一个程序使用 fork() 函数创建了一
个子进程时，通常会在该子进程中调用 execve() 函数加载执行另一个新程序。
此时子进程将完全被新程序替换掉，并在子进程中开始执行新程序。若一个文件
描述符在 close_on_exec 中的对应比特位被设置，那么在执行 execve() 时
该描述符将被关闭，否则该描述符将始终处于打开状态。当打开一个文件时，
默认情况下文件句柄在子进程中也处于打开状态。因此 sys_open() 中要复位
对应比特位。

struct fdtable 结构中 full_fds_bits 和 open_fds 都是 bitmap，
max_fds 代表该结构能够维护最大文件描述数，max_fds 的值决定
了 open_fds 的 bits 数。在 open_fds 指向的 bitmap 中，bit
从低位开始编码，每个 bit 对应一个文件描述符，即 bit0 代表
的文件描述符就是 0，bit1 代表的文件描述符就是 1. 在
open_fds 的 bitmap 中，置位的 bit 对应的文件描述符已经分配，
反之该 bit 清零则表示该文件描述符没有分配。同理 full_fds_bits
也是一个 bitmap，并且从低位开始编码，但 full_fds_bits 的每个
bit 指代 open_fds 中的 32 个 bit，即 full_fds_bits 的 bit0
代表了 open_fds 的 0 到 31 bit, full_fds_bits 的 bit-1
代表了 open_fds 的 32 到 63 bit, 如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000025.png)

-------------------------------------

#### <span id="A00013">struct nameidata</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000030.png)

-------------------------------------

#### <span id="A00016">filp_cachep</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000033.png)

filp_cachep 是一个 "struct file" 的缓存。由于内核运行过程中，需要
大量的申请和释放 "struct file" 结构，为了减小这样操作带来的开销，
系统在初始化过程中从 SLAB 中分配了一段缓存用于 "struct file" 的分配
和释放。

filp_cachep 的初始化如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000034.png)

系统初始化过程中，调用 files_init() 函数，并在函数内部调用
kmem_cache_create() 函数分配缓存，缓存的名字是 "filp", 大小为
"sizeof(struct file)".

-------------------------------------

#### <span id="A00017">open_flags</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000038.png)

struct open_flags 数据结构用于管理文件打开的标志，访问权限、路径查找以及
意图等信息。open_flag 用于存储文件打开的标志，其包含了 VALID_OPEN_FLAGS
所支持的标志，并经过内核的处理，无效的标志已被剔除。mode 成员用于维护
文件打开的权限，该权限用于管理访问文件时候，文件拥有者、文件所属组、
其他用户具有的权限。acc_mode 成员文件的访问权限，其从文件打开标志中，
通过 ACC_MODE() 宏和相关处理，获得文件的访问模式。intent 用于存储文件
打开的意图，包括文件路径对于的是文件还是路径等信息。lookup_flags 成员
用于存储文件打开是对路径等查找过程使用的标志。更多文件标志信息可以参考:

> - [文件标志详解](https://biscuitos.github.io/blog/open-flags/)

----------------------------------

<span id="B0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000G.jpg)

## Open 系统调用实践

----------------------------------

<span id="C0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000K.jpg)

## Open 源码分析

> - [getname_flags](#C00001)
>
> - [find_next_fd](#C00002)
>
> - [\_\_set_open_fd](#C00003)
>
> - [\_\_set_close_on_exec](#C00004)
>
> - [\_\_set_clear_on_exec](#C00005)
>
> - [\_\_alloc_fd](#C00006)
>
> - [\_\_alloc_file](#C00007)
>
> - [alloc_empty_file](#C00008)
>
> - [ACC_MODE](#C00009)
>
> - [build_open_flags](#C0000A)


---------------------------------

#### <span id="C00001">getname_flags</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000000.png)

函数的主要作用就是通过检查用户空间传递的文件路径名长度是否合法，如果
合法内核就使用 "struct filename" 将路径名管理起来。
参数 filename 指向用户空间的文件路径名，参数 flags 代表文件路径处理
标志，empty 参数用于特定的空路径处理。
函数定义了三个局部变量, 分别是 struct filename 结构的 "result",
字符指针 "kname", 以及用于表达长度的整形变量 "len". 
"struct filename" 定义在 "linux/fs.h", 其定义如下:

{% highlight c %}
/* fs/open.c */
struct audit_names;
struct filename {
        const char              *name;  /* pointer to actual string */
        const __user char       *uptr;  /* original userland pointer */
        int                     refcnt;
        struct audit_names      *aname;
        const char              iname[];
};
{% endhighlight %}

函数首先调用 "BUILD_BUG_ON()" 宏对 "struct filename" 中的 iname
位置进行判断，这里使用了 offsetof() 宏进行判断，该宏可以计算出
结构体成员在结构体中的位置，即起始偏移，例如使用该宏对 "struct filename"
的结构体进行 offsetof 解析之后，可以得到如下结果:

{% highlight c %}
offsetof(struct filename, name)       ---> 0
offsetof(strcut filename, uptr)       ---> 4
offsetof(strcut filename, refcnt)     ---> 8
offsetof(strcut filename, anme)       ---> 12
offsetof(strcut filename, iname)      ---> 16
offsetof(strcut filename, iname[0])   ---> 16
offsetof(strcut filename, iname[1])   ---> 17
{% endhighlight %}

因此从上面的结果可以看出，"BUILD_BUG_ON()" 宏在此处检查 
"struct filename" 的 iname 其实地址是否按地址总线长度对齐，
由于 "sizeof()" 的对象是 long，那么起长度就是地址总线的
长度。此处，如果 iname 成员没有按要求对其，那么内核将作为
BUG 进行报错。

{% highlight c %}
        result = audit_reusename(filename);
        if (result)
                return result;
{% endhighlight %}

audit_reusename() 函数用于对从用户空间的 filename 进行统计，
如果内核没有开启 CONFIG_AUDIT 宏，函数实现为空。

{% highlight c %}
        result = __getname();
        if (unlikely(!result))
                return ERR_PTR(-ENOMEM);
{% endhighlight %}

\_\_getname() 函数用于从 "names_cachep" 缓存中分配一个 "struct filename"
结构实例，names_cachep 是内核构建的一个 "struct filename" 缓存，系统
初始化过程中，调用 vfs_caches_init() 函数进行创建，其实现如下:

{% highlight c %}
struct kmem_cache *names_cachep __read_mostly;
#define PIPE_BUF        4096    /* # bytes in atomic write to a pipe */

void __init vfs_caches_init(void)
{
        names_cachep = kmem_cache_create_usercopy("names_cache", PATH_MAX, 0,
                        SLAB_HWCACHE_ALIGN|SLAB_PANIC, 0, PATH_MAX, NULL);
}

#define __getname()             kmem_cache_alloc(names_cachep, GFP_KERNEL)
{% endhighlight %}

从上面的实现可以看出，系统为 "struct filename" 创建的缓存大小为
PATH_MAX, 长度为 4096，但从 "struct filename" 的定义来看，其包含了
一个空的字符数组，因此缓存大小定义为 PATH_MAX 之后，除去 struct filename
本身的大小，剩余的空间都通过 struct filename 的 iname 数组进行管理，
其大小为:

{% highlight c %}
length = PATH_MAX - offsetof(struct filename, iname) = 4096 - 16 = 4080
{% endhighlight %}

因此通过 __getname() 获得的 struct filename 就包含了一个长度
为 4080 的字符数组。

{% highlight c %}
#define EMBEDDED_NAME_MAX       (PATH_MAX - offsetof(struct filename, iname))

        /*
         * First, try to embed the struct filename inside the name_cache
         * allocation.
         */ 
        kname = (char *)result->iname;
        result->name = kname;

        len = strncpy_from_user(kname, filename, EMBEDDED_NAME_MAX);
        if (unlikely(len < 0)) {
                __putname(result);
                return ERR_PTR(len);
        }
{% endhighlight %}

函数接下来将 struct filename 的 name 成员指向了 iname 指向的
字符数组，此时 kname 变量指向了 struct filename 的字符数组空间，
该字符空间用于存储用户空间传递的字符串，该字符串用于存储要打开
文件的路径名。接着函数使用 strncpy_from_user() 函数将用户空间
的 filename 字符串安全拷贝到内核的 kname 指向的内存空间，拷贝
的长度为 EMBEDDED_NAME_MAX, 通过上面的分析可以知道该长度为
4080，也就是 struct filename 可以存储的最大字符数。如果函数执行
失败，那么调用 \_\_putname() 函数将从 names_cachep 分配的 
struct filename 结构返还给 names_cachep, 并返回错误代码 
"ERR_PTR(len)"; 反之如果函数执行成功，那么 struct filename 
的 name 和 iname 都指向了从用户空间拷贝过来的字符串。

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000001.png)

{% highlight c %}
        /*
         * Uh-oh. We have a name that's approaching PATH_MAX. Allocate a
         * separate struct filename so we can dedicate the entire
         * name_cache allocation for the pathname, and re-do the copy from
         * userland.
         */
        if (unlikely(len == EMBEDDED_NAME_MAX)) {
                const size_t size = offsetof(struct filename, iname[1]);
                kname = (char *)result;
{% endhighlight %}

如果用户空间 open 打开的文件名字的长度介于 EMBEDDED_NAME_MAX 
与 PATH_MAX 之间, 那么函数就新分配一个分离的 "struct filename",
用于存储 open 的路径名，以便区分 "struct filename" 是 names_cachep
分配还是独立分配的，但如果 open 打开的路径名长度超过或等于
PATH_MAX, 那么系统就相应的报错，以此奠定内核支持的最大路径名。 
函数首先调用 "offsetof(struct filename, iname[1])" 获得
"struct filename" 的原始长度，该长度不包含 names_cachep 分配
的字符串长度，并将 kname 指向了原先的 struct filename 结构，

{% highlight c %}
                /*
                 * size is chosen that way we to guarantee that
                 * result->iname[0] is within the same object and that
                 * kname can't be equal to result->iname, no matter what.
                 */
                result = kzalloc(size, GFP_KERNEL);
                if (unlikely(!result)) {
                        __putname(kname);
                        return ERR_PTR(-ENOMEM);
                }
                result->name = kname;
                len = strncpy_from_user(kname, filename, PATH_MAX);
                if (unlikely(len < 0)) {
                        __putname(kname);
                        kfree(result);
                        return ERR_PTR(len);
                }
                if (unlikely(len == PATH_MAX)) {
                        __putname(kname);
                        kfree(result);
                        return ERR_PTR(-ENAMETOOLONG);
                }
{% endhighlight %}

函数接着调用 kzalloc() 函数从 SLAB 子系统中分配了一块内存用于存储
新的 "struct filename", 并调用 "result->name = kname" 代码，将新的
"struct filename" 的 name 指向了原始 "struct filename" 结构, 接着
调用 strncpy_from_user() 函数从用户空间拷贝长度为 PATH_MAX 的字符串，
如果一切顺利，原始的 "struct filename" 就用来全部存储字符串。如果
此时 len 的值就拷贝字符串长度为 PATH_MAX，代表 open 打开文件名超过
了 PATH_MAX, 此时函数就返回 -ENAMETOOLONG, 以此表示打开的文件名
太长。如果名字长度在 EMBEDDED_NAME_MAX 到 PATH_MAX 之间，那么
新旧 "struct filename" 的逻辑关系如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000002.png)

{% highlight c %}
        result->refcnt = 1;
        /* The empty path is special. */
        if (unlikely(!len)) {
                if (empty)
                        *empty = 1;
                if (!(flags & LOOKUP_EMPTY)) {
                        putname(result);
                        return ERR_PTR(-ENOENT);
                }
        }

        result->uptr = filename;
        result->aname = NULL;
        audit_getname(result);
        return result;
{% endhighlight %}

函数目前已经使用一个 struct filename 管理从用户空间获得的路径名，
由于上面分析了不同长度路径名采用不同的 "struct filename" 管理
策略，函数讲最终使用的 "struct filename" 的 refcnt 设置为 1，
以此表示该 "struct filename" 正在使用。如果 len 为零，表示特殊的
路径，这里不做详细分析。接着函数讲 "struct filename" 的 uptr 指向
了用户空间的 filename 字符串，并将 aname 设置为 NULL。函数最后返回
"struct filename"。

研究完源码之后，这里对 open 打开的路径名进行进一步研究，
相关的研究文档如下:

> - [Open 打开路径长度研究](https://biscuitos.github.io/blog/open-namelen/)

---------------------------------

#### <span id="C00002">find_next_fd</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000024.png)

find_next_fd() 函数用于从当前进程的文件描述符中获得一个未使用的
文件描述符。参数 fdt 指向文件描述符结构 "struct fdtable"，参数
start 代表开始查找的文件描述符。

内核中每个进程维护着当前进程所打开的文件，每个文件都使用当前进程能够
区分的文件描述符表示。对于当前进程，文件描述符就是一个唯一的整数，但
对于其他进程是不唯一的，也就是文件描述符值相同，但不一定是同一个文件。
内核使用 struct fdtable 结构维护当前进程所有打开的文件描述符。其定义
如下:

{% highlight c %}
struct fdtable {
        unsigned int max_fds;
        struct file __rcu **fd;      /* current fd array */
        unsigned long *close_on_exec;
        unsigned long *open_fds;
        unsigned long *full_fds_bits;
        struct rcu_head rcu;
};
{% endhighlight %}

struct fdtable 结构中 full_fds_bits 和 open_fds 都是 bitmap，
max_fds 代表该结构能够维护最大文件描述数，max_fds 的值决定
了 open_fds 的 bits 数。在 open_fds 指向的 bitmap 中，bit 
从低位开始编码，每个 bit 对应一个文件描述符，即 bit0 代表
的文件描述符就是 0，bit1 代表的文件描述符就是 1. 在 
open_fds 的 bitmap 中，置位的 bit 对应的文件描述符已经分配，
反之该 bit 清零则表示该文件描述符没有分配。同理 full_fds_bits
也是一个 bitmap，并且从低位开始编码，但 full_fds_bits 的每个
bit 指代 open_fds 中的 32 个 bit，即 full_fds_bits 的 bit0
代表了 open_fds 的 0 到 31 bit, full_fds_bits 的 bit-1
代表了 open_fds 的 32 到 63 bit, 如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000025.png)

工具上面的原理可以知道，函数首先获得 struct fdtable 支持的
最大文件描述符值，即 max_fds 的值。接着计算 max_fds 位于 
位于 full_fds_bits 的位置，此处调用 find_next_zero_bit()
函数可以从 start 开始查找 full_fds_bits 中第一个清零的位置，
在 full_fds_bis 中，如果某个 bit 置位，那么表示该 bit 对于
的 32 个文件描述符都已经分配了。找到第一个可用的 bit 之后，
进而获得该 bit 在 open_fds 中起始 bit。接下来就是判断该
起始地址是否超过 "struct fdtable" 维护的最大文件描述符，
如果超过，那么直接返回 maxfd。如果找到的文件描述符值比 start
大，那么将 start 设置为 bitbit. 最后调用 find_next_zero_bit()
函数从 start 开始到 maxfd 结束，在 open_fds 中查找一个
未使用的文件描述符.

> - [find_next_zero_bit 函数实践](https://biscuitos.github.io/blog/BITMAP_find_next_zero_bit/)

---------------------------------

#### <span id="C00003">\_\_set_open_fd</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000026.png)

\_\_set_open_fd() 函数用于置位 open_fds 中的文件描述符。参数 fd
表示一个文件描述符，参数 fdt 指向当前进行的 struct fdtable 结构。
struct fdtable 结构中 full_fds_bits 和 open_fds 都是 bitmap，
max_fds 代表该结构能够维护最大文件描述数，max_fds 的值决定
了 open_fds 的 bits 数。在 open_fds 指向的 bitmap 中，bit
从低位开始编码，每个 bit 对应一个文件描述符，即 bit0 代表
的文件描述符就是 0，bit1 代表的文件描述符就是 1. 在
open_fds 的 bitmap 中，置位的 bit 对应的文件描述符已经分配，
反之该 bit 清零则表示该文件描述符没有分配。同理 full_fds_bits
也是一个 bitmap，并且从低位开始编码，但 full_fds_bits 的每个
bit 指代 open_fds 中的 32 个 bit，即 full_fds_bits 的 bit0
代表了 open_fds 的 0 到 31 bit, full_fds_bits 的 bit-1
代表了 open_fds 的 32 到 63 bit, 如下图:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000025.png)

函数首先使用 __set_bit() 函数将 fd 对应的 open_fds bit 位置位，
然后检查该 bit 位对于的 full_fds_bits 的 32 个 bits 是否都已经
置位，如果置位，那么将对应的 full_fds_bits 置位.

> - [\_\_set_bit() 函数实践](https://biscuitos.github.io/blog/BITMAP___set_bit/)

---------------------------------

#### <span id="C00004">\_\_set_close_on_exec</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000027.png)

__set_close_on_exec() 函数用于将一个文件描述符添加到 struct fdtable
结构的 close_on_exec bitmap 中。参数 fd 指向文件描述符，参数 fdt
指向当前进程的 struct fdtable 数据结构。

close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特
位代表一个打开的文件描述符，用于确定在调用系统调用 execve() 时需要关闭
的文件句柄。当一个程序使用 fork() 函数创建了一个子进程时，通常会在该子
进程中调用 execve() 函数加载执行另一个新程序。此时子进程将完全被新程序
替换掉，并在子进程中开始执行新程序。

若一个文件描述符在 close_on_exec 中的对应比特位被设置，那么在执行
execve() 时该描述符将被关闭，否则该描述符将始终处于打开状态。当打开
一个文件时，默认情况下文件句柄在子进程中也处于打开状态。因此
sys_open() 中要复位对应比特位。

> - [\_\_set_bit() 函数实践](https://biscuitos.github.io/blog/BITMAP___set_bit/)

---------------------------------

#### <span id="C00005">\_\_clear_close_on_exec</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000028.png)

__clear_close_on_exec() 函数用于将一个文件描述符从当前进程的
struct fdtable 结构 close_on_exec 中移除。 参数 fd 代表文件描述符，
fdt 指向当前进行的 fdtable。

close_on_exec 是一个进程所有文件描述符（文件句柄）的位图标志，每个比特
位代表一个打开的文件描述符，用于确定在调用系统调用 execve() 时需要关闭
的文件句柄。当一个程序使用 fork() 函数创建了一个子进程时，通常会在该子
进程中调用 execve() 函数加载执行另一个新程序。此时子进程将完全被新程序
替换掉，并在子进程中开始执行新程序。

若一个文件描述符在 close_on_exec 中的对应比特位被设置，那么在执行
execve() 时该描述符将被关闭，否则该描述符将始终处于打开状态。当打开
一个文件时，默认情况下文件句柄在子进程中也处于打开状态。因此
sys_open() 中要复位对应比特位。

> - [\_\_clear_bit() 函数实践](https://biscuitos.github.io/blog/BITMAP___clear_bit/)

---------------------------------

#### <span id="C00006">\_\_alloc_fd</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000029.png)

__alloc_fd() 函数用于从当前进程中获得一个可用的文件描述符。
参数 files 指向当前进行的 struct files_struct, 参数 start
指向文件描述符开始查找的位置，参数 end 指向文件描述符结束
的位置，flags 参数包含获得文件描述符的标志。函数定义了三个
局部变量，fd 用于存储文件描述符，error 用于存储错误代码，
参数 fdt 用于指向一个 struct fdtable.

{% highlight c %}
        spin_lock(&files->file_lock);
repeat:
        fdt = files_fdtable(files);
        fd = start;
        if (fd < files->next_fd)
                fd = files->next_fd;

        if (fd < fdt->max_fds)
                fd = find_next_fd(fdt, fd);
{% endhighlight %}

函数首先调用 spin_lock() 加上锁，然后调用 files_fdtable() 函数
获得 files 参数对于的 struct fdtable 结构，并将局部变量 fd 设置
成 start。struct files_struct 结构 next_fd 成员包含了当前进程
下一个可用的文件描述符，如果此时 fd 当前进程下一个可用文件描述符，
那么将 fd 设置为 files->next_fd. 如果此时 fd 的值小于当前进程支持
的最大文件描述符，那么函数就调用 find_next_fd() 函数在当前进程
中查找一个可用的文件描述符。

在内核中，当前进程与文件相关的数据结构维护在 struct task_struct 
的 files 成员里，其是一个 struct files 结构。struct files 结构
中包含了成员 fdtab 成员，该成员属于 struct fdtable 结构，该结构
专门用于管理进程的文件描述符，其定义如下:

{% highlight c %}
struct fdtable {
        unsigned int max_fds;
        struct file __rcu **fd;      /* current fd array */
        unsigned long *close_on_exec;
        unsigned long *open_fds;
        unsigned long *full_fds_bits;
        struct rcu_head rcu;
};
{% endhighlight %}

struct fdtable 存在三个 bitmap，在这里涉及到 open_fds 和 full_fds_bits 
两个 bitmap，通过两个 bitmap 可以获得一个可用的文件描述符，逻辑关系如下:

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000025.png)

更多 struct fdtable 信息请查看:

> - [struct fdtable](#A00012)
>
> - [find_next_fd](#C00002)

{% highlight c %}
        /*
         * N.B. For clone tasks sharing a files structure, this test
         * will limit the total number of files that can be opened.
         */
        error = -EMFILE;
        if (fd >= end)
                goto out;

        error = expand_files(files, fd);
        if (error < 0)
                goto out;
{% endhighlight %}

函数继续执行上面的代码，每当当前进程打开的文件数量超过 fdtable
支持的最大文件数且小于系统支持的最大文件数，那么函数就会调用 
expand_files() 函数，以此扩大当前进程所支持的最大文件数。

{% highlight c %}
        /*
         * If we needed to expand the fs array we
         * might have blocked - try again.
         */
        if (error)
                goto repeat;

        if (start <= files->next_fd)
                files->next_fd = fd + 1;

        __set_open_fd(fd, fdt);
        if (flags & O_CLOEXEC)
                __set_close_on_exec(fd, fdt);
        else
                __clear_close_on_exec(fd, fdt);
        error = fd;
{% endhighlight %}

函数在获得一个可用的文件描述符之后，函数更新当前进程下一个
可用的文件描述符，即 "files->next_fd = fd + 1", 函数接着
调用 __set_open_fd() 函数将获得的文件描述符在当前进程的
fdtable 里面标记，以此表示该文件描述符已经被使用。函数接着判断
flags 参数是否包含 O_CLOEXEC 标志，如果包含，那么函数会设置
fdtable 的 close_on_exec 位图，该位图用于 execv() 返回时要
关闭的文件描述符。如果支持 O_CLOEXEC, 那么函数调用 __set_close_on_exec()
函数将文件描述符再 close_on_exec 对于的 bit 位置位；反之
则调用 __clear_on_exec() 函数将文件描述符从 close_on_exec 位图
中移除。更多细节可以参考:

> - [\_\_set_open_fd](#C00003)
>
> - [\_\_set_close_on_exec](#C00004)
>
> - [\_\_set_clear_on_exec](#C00005)

{% highlight c %}
        /* Sanity check */
        if (rcu_access_pointer(fdt->fd[fd]) != NULL) {
                printk("alloc_fd: slot %d not NULL!\n", fd);
                rcu_assign_pointer(fdt->fd[fd], NULL);
        }

out:
        spin_unlock(&files->file_lock);
        return error;
{% endhighlight %}

函数最后对 fdt->fd[fd] 进行检测，以此确保该文件描述符没有
对应一个已经打开的文件。如果此时已经对应一个打开的文件，那么
系统提示相应的错误信息。函数最后调用 spin_unlock() 函数进行
解锁并返回 error 错误值。


---------------------------------

#### <span id="C00007">\_\_alloc_file</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000031.png)

__alloc_file() 函数用于分配一个新的 "struct file" 结构，并初始化
"struct file" 的基础内容。参数 flags 包含了打开文件的标志，参数
cred 是与认证和令牌相关的信息。函数定义了两个局部变量，f 是一个
文件只做，error 变量用于存储错误信息。

函数首先调用 kmem_cache_zalloc() 从 file_cachep 缓存中分配一个
"struct file" 的空间给 f，如果分配失败，则返回 ENOMEM。接下来
初始化该 struct file. 将 struct file 的 f_cred 设置为 get_cred(cred),
以此设置 struct file 的认证信息。如果内核没有开启 CONFIG_SECURITY
功能，那么 security_file_alloc() 函数没有任何作用，直接返回 0。
函数继续将 struct file 的 f_count 设置为 1，以此表示有一个使用者，
接着初始化 struct file 的读写锁，mutex 锁以及自旋锁。接着函数调用
eventpoll_init_file() 函数初始化 struct file 的 epoll，该设置必须在
内核启用 CONFIG_EPOLL 的前提下有效。然后将 struct file 的 f_flags
设置为参数 flags，以及打开模式 f_mode 设置为 OPEN_FMODE(flags) 的值。
经过上面的处理，struct file 的基础数据已经被初始化。

---------------------------------

#### <span id="C00008">alloc_empty_file</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000032.png)

alloc_empty_file() 函数用于分配一个未使用的 "struct file"，初始化基础
数据之后返回指向 "struct file" 的指针。参数 flags 包含打开文件的标志信息，
参数 cred 指向令牌和认证信息。函数定义了两个局部变量，old_max 变量用于储存
内核支持的打开文件数，参数 f 是一个指向 struct file 的指针，用于指向
未使用的 struct file.

{% highlight c %}
        /*
         * Privileged users can go above max_files
         */
        if (get_nr_files() >= files_stat.max_files && 
                                                !capable(CAP_SYS_ADMIN)) {
                /*
                 * percpu_counters are inaccurate. Do an expensive check before
                 * we go and fail.
                 */
                if (percpu_counter_sum_positive(&nr_files) >=
                                                        files_stat.max_files)
                        goto over;
        }
{% endhighlight %}

函数首先调 get_nr_files() 获得当前系统进程支持的最大文件打开数，默认为 32，
"files_stat.max_files" 代码可以获得当前系统可以支持的最大文件打开数量。
"capable(CAP_SYS_ADMIN)" 代码用于检查是否支持 CAP_SYS_ADMIN, 该权限允许
执行系统管理任务：加载/卸载文件系统、设置磁盘配额、开/关交换设备和文件等。
函数在这段代码片段中首先判断当前进程打开文件数是否已经超过系统支持的最大
文件打开数，如果大于，那么函数检查系统是否具有 CAP_SYS_ADMIN 权限，如果
此时没有该权限，那么函数就执行这段代码。进入这段代码之后，函数再次调用
percpu_counter_sum_positive() 函数确定当前进程打开数是否大于当前系统最大
支持打开文件数。如果真的大于，那么跳转到 over。

{% highlight c %}
over:
        /* Ran out of filps - report that */
        if (get_nr_files() > old_max) {
                pr_info("VFS: file-max limit %lu reached\n", get_max_files());
                old_max = get_nr_files();
        }
        return ERR_PTR(-ENFILE);
{% endhighlight %}

如果函数跳转到 over 处，那么函数判断 get_nr_files() 是否大于 old_max,
那么系统进行报错，并返回 ERR_PTR(-ENFILE).

{% highlight c %}
        f = __alloc_file(flags, cred);
        if (!IS_ERR(f))
                percpu_counter_inc(&nr_files);

        return f;
{% endhighlight %}

如果当前进程文件打开数没有超过系统最大文件打开数，那么函数调用
__alloc_file() 函数获得一个 "struct file", 并使用 f 指向该 
"struct file", 如果获取过程中没有报错，那么函数调用
"percpu_counter_inc()" 函数增加 nr_files 的数量。最后
返回 f 指针。

> - [\_\_alloc_file](#C00007)

---------------------------------

#### <span id="C00009">ACC_MODE</span>

{% highlight c %}
#define O_ACCMODE       00000003
#define ACC_MODE(x) ("\004\002\006\006"[(x)&O_ACCMODE])
{% endhighlight %}

ACC_MODE() 宏用于过滤并获得打开文件的访问权限。在用户空间再打开文件
的时候传入相应的访问权限，比如: O_RDONLY(0x00), O_WRONLY(0x01),
O_RDWR(0x02)。因此访问模式就是包括只读，只写以及可读可写。

{% highlight c %}
ACC_MODE[0]        ----> 0x4
ACC_MODE[1]        ----> 0x2
ACC_MODE[2]        ----> 0x6
ACC_MODE[3]        ----> 0x6
{% endhighlight %}

---------------------------------

#### <span id="C0000A">build_open_flags</span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/HK/HK000037.png)

build_open_flags() 函数用于处理打开文件的标志和模式信息。参数 flags
指向打开文件的标志，mode 参数指向打开文件的模式，op 参数是一个
open_flags 结构。函数还定义了两个参数，第一个是 lookup_flags 用于
文件查找时使用的标志信息，第二个 acc_mode 用于存储文件的模式信息。
内核使用 struct open_flags 结构存储文件打开标志，访问模式以及查找标志
等信息，定义如下:

{% highlight c %}
/*
 * open.c
 */
struct open_flags {
        int open_flag;
        umode_t mode;
        int acc_mode;
        int intent;
        int lookup_flags;
};
{% endhighlight %}

struct open_flags 结构中，open_flag 用于存储打开文件的标志，mode 用于
存储打开文件的模式，acc_mode 用于存储文件的访问模式，lookup_flags 用于
存储文件查找的标志。

函数首先使用 ACC_MODE() 宏从文件打开标志中获得访问模式，内核支持
三种访问模式: O_RDONLY、O_WRONLY 和 O_RDWR. 接着将打开文件的标志
与 VALID_OPEN_FLAGS 相与，VALID_OPEN_FLAGS 内包含了内核支持的打开
文件标志，以此过滤调不符合要求的打开标志，其定义如下:

{% highlight c %}
#define VALID_OPEN_FLAGS \ 
        (O_RDONLY | O_WRONLY | O_RDWR | O_CREAT | O_EXCL | O_NOCTTY | O_TRUNC | \       
         O_APPEND | O_NDELAY | O_NONBLOCK | O_NDELAY | __O_SYNC | O_DSYNC | \
         FASYNC | O_DIRECT | O_LARGEFILE | O_DIRECTORY | O_NOFOLLOW | \
         O_NOATIME | O_CLOEXEC | O_PATH | __O_TMPFILE)
{% endhighlight %}

具体每个标志的含义，请参考下面文章:

> - [open 打开标志详解](https://biscuitos.github.io/blog/open-flags/)

{% highlight c %}
        if (flags & (O_CREAT | __O_TMPFILE))
                op->mode = (mode & S_IALLUGO) | S_IFREG;
        else
                op->mode = 0;
{% endhighlight %}

O_CREAT 标志表示如果文件不存在就创建一个新文件，__O_TMPFILE 标识
表示创建一个无名的临时文件，文件系统中会创建一个无名的 inode，当
最后一个文件描述符被关闭的时候，所有写入这个文件的内容都会丢 失
除非在此之前给了它一个名字. 函数首先判断打开标志是否包含
O_CREATE 和 __O_TMPFILE 两个标志，这两个标志都会触发系统创建
新文件，并且文件创建时，open 系统调用需要包含文件模式信息。
如果包含，那么将 struct open_flags 的 mode 成员中添文件打开文件
模式信息，这里 S_IALLUGO 是文件拥有者，文件拥有组以及其他用户的
模式掩码，再这种情况下，将打开文件的模式信息加上 S_IFREG 标志，
以此表示创建的是一个文件; 反之系统不用创建文件，那么 struct open_flags
的 mode 成员为 0，也就是不使用。

{% highlight c %}
        /* Must never be set by userspace */
        flags &= ~FMODE_NONOTIFY & ~O_CLOEXEC;
{% endhighlight %}

函数从打开文件标志中剔除了 FMODE_NONOTIFY 和 O_CLOEXEC，
内核规定用户空间打开标志不能包含以上两个标志。

{% highlight c %}
        /*
         * O_SYNC is implemented as __O_SYNC|O_DSYNC. As many places only
         * check for O_DSYNC if the need any syncing at all we enforce it's
         * always set instead of having to deal with possibly weird behaviour
         * for malicious applications setting only __O_SYNC.
         */
        if (flags & __O_SYNC)
                flags |= O_DSYNC;
{% endhighlight %}

函数继续检查打开标是否包含 __O_SYNC, 在有的体系中，对于同步操作，一般
使用 O_DSYNC, O_DSYNC 表示根据同步 I/O 数据完整性的完成要求来执行文件
写操作。

{% highlight c %}
        if (flags & __O_TMPFILE) {
                if ((flags & O_TMPFILE_MASK) != O_TMPFILE)
                        return -EINVAL;
                if (!(acc_mode & MAY_WRITE))
                        return -EINVAL;
        } else if (flags & O_PATH) {
{% endhighlight %}

函数继续检查打开标志是否包含 __O_TMPFILE, 即表示系统是否创建一个
零时文件。如果包含，那么文件系统中会创建一个无名的 inode，当
最后一个文件描述符被关闭的时候，所有写入这个文件的内容都会丢 失
除非在此之前给了它一个名字. 此处函数首先判断打开文件是否包含
__O_TMPFILE 标志，如果包含，如果函数此时检查到打开文件中不包含
O_TMPFILE，那么系统就返回 -EINVAL. 由于系统需要创建一个零时文件，
因此文件模式必须包含写权限，因此函数继续检查 acc_mode 是否包含
了 MAY_WRITE 写权限，如果不包含，函数直接返回 -EINVAL.

{% highlight c %}
        } else if (flags & O_PATH) {
                /*
                 * If we have O_PATH in the open flag. Then we
                 * cannot have anything other than the below set of flags
                 */
                flags &= O_DIRECTORY | O_NOFOLLOW | O_PATH;
                acc_mode = 0;
        }
{% endhighlight %}

如果此时函数打开标志中不包含 __O_TMPFILE, 那么函数继续检查打开
标志是否包含 O_PATH 标志，O_PATH 标志表示获得一个能表示文件在文
件系统中位置的文件描述符。那么打开标志只能包含 O_DIRECTORY、O_PATH
和 O_NOFOLLOW 标志，并且访问模式设置为 0，即忽略访问模式信息。

{% highlight c %}
        op->open_flag = flags;

        /* O_TRUNC implies we need access checks for write permission */
        if (flags & O_TRUNC)
                acc_mode |= MAY_WRITE;
{% endhighlight %}

函数将处理好的打开文件标志存储在 struct open_flags 的 flag 成员里。
函数继续检查打开标志中是否包含 O_TRUNC 标志，该标志表示如果文件已经
存在且为普通文件，那么清空文件内容，将其长度置为 0. 在 Linux 下使用
此标志，无论以读、写方式打开文件，都可清空文件 内容 (在这种情况下，
都必须拥有对文件的写权限), 因此在访问权限中添加可写标志 MAY_WRITE.

{% highlight c %}
        /* Allow the LSM permission hook to distinguish append
         * access from general write access.
         */
        if (flags & O_APPEND)
                acc_mode |= MAY_APPEND;

        op->acc_mode = acc_mode;
        op->intent = flags & O_PATH ? 0 : LOOKUP_OPEN;
{% endhighlight %}

函数继续判断打开标志中是否包含 O_APPEND 标志，如果包含，那么
系统运行使用 hook，并加入 MAY_APPEND 标志，以此区分正常的末尾
写操作。函数继续将 acc_mode 的值存储到在 struct open_flags 结构
的 acc_mode 成员里。如果打开文件包含了 O_PATH 标志，那么函数
就将 struct open_flags 的 intent 设置为 0; 反之设置为 LOOKUP_OPEN
表示查找的内容是文件而不是目录。

{% highlight c %}
        if (flags & O_CREAT) {
                op->intent |= LOOKUP_CREATE;
                if (flags & O_EXCL)
                        op->intent |= LOOKUP_EXCL;
        }
{% endhighlight %}

函数如果检查到文件打开标志中含有 O_CREAT 标志，那么意图是去创建
一个文件，因此函数将 LOOKUP_CREATE 加入到 struct open_flags 的 
intent 成员里，告诉使用该结构体的函数，内核试图创建一个文件。如果
此时文件打开标志中还包含了 O_EXCL 标志，那么函数将 LOOKUP_EXCL 
标志，以此表示内核试图创建一个不存在的文件。

{% highlight c %}
        if (flags & O_DIRECTORY)
                lookup_flags |= LOOKUP_DIRECTORY;
        if (!(flags & O_NOFOLLOW))
                lookup_flags |= LOOKUP_FOLLOW;
        op->lookup_flags = lookup_flags;
        return 0;
{% endhighlight %}

函数接着检查 flags 是否包含 O_DIRECTORY, 如果包含，那么函数添加
LOOKUP_DIRECTORY 标志，以此表示内核试图找到一个目录。函数接着
检查 flags 中是否包含 O_NOFOLLOW 标志，如果不包含，那么函数添加
LOOKUP_NOFOLLOW 标志，以此表示系统正在查找一个链接文件。最后
将 lookup_flags 收集到的信息存储到了 struct open_flags 的 intent
成员里，最后返回 0.

> - [文件打开相关标志详解](https://biscuitos.github.io/blog/open-flags/)

----------------------------------------------------













{% highlight c %}

{% endhighlight %}



----------------------------------

<span id="D0"></span>

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/IND00000L.jpg)

## Open 进阶研究

> - [Open 打开路径长度研究](https://biscuitos.github.io/blog/open-namelen/)
>
> - [Open 文件打开标志、文件权限标志、查找标志研究](https://biscuitos.github.io/blog/open-flags/)

-----------------------------------------------

# <span id="Z0">附录</span>

> [BiscuitOS Home](https://biscuitos.github.io/)
>
> [Linux Kernel](https://www.kernel.org/)
>
> [Bootlin: Elixir Cross Referencer](https://elixir.bootlin.com/linux/latest/source)

## 赞赏一下吧 🙂

![](https://gitee.com/BiscuitOS_team/PictureSet/raw/Gitee/BiscuitOS/kernel/HAB000036.jpg)
